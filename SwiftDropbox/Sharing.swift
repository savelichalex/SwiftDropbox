
/* Autogenerated. Do not edit. */

import Foundation
/**
    Datatypes and serializers for the sharing namespace
*/
open class Sharing {
    /**
        Who can access a shared link. The most open visibility is public. The default depends on many aspects, such as
        team and user preferences and shared folder settings.
    */
    public enum Visibility: CustomStringConvertible {
        /**
            Anyone who has received the link can access it. No login required.
        */
        case `public`
        /**
            Only members of the same team can access the link. Login is required.
        */
        case teamOnly
        /**
            A link-specific password is required to access the link. Login is not required.
        */
        case password
        /**
            Only members of the same team who have the link-specific password can access the link.
        */
        case teamAndPassword
        /**
            Only members of the shared folder containing the linked file can access the link. Login is required.
        */
        case sharedFolderOnly
        /**
            An unknown restriction is in place.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(VisibilitySerializer().serialize(self)))"
        }
    }
    open class VisibilitySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Visibility) -> JSON {
            switch value {
                case .public:
                    var d = [String : JSON]()
                    d[".tag"] = .str("public")
                    return .dictionary(d)
                case .teamOnly:
                    var d = [String : JSON]()
                    d[".tag"] = .str("team_only")
                    return .dictionary(d)
                case .password:
                    var d = [String : JSON]()
                    d[".tag"] = .str("password")
                    return .dictionary(d)
                case .teamAndPassword:
                    var d = [String : JSON]()
                    d[".tag"] = .str("team_and_password")
                    return .dictionary(d)
                case .sharedFolderOnly:
                    var d = [String : JSON]()
                    d[".tag"] = .str("shared_folder_only")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> Visibility {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "public":
                            return Visibility.public
                        case "team_only":
                            return Visibility.teamOnly
                        case "password":
                            return Visibility.password
                        case "team_and_password":
                            return Visibility.teamAndPassword
                        case "shared_folder_only":
                            return Visibility.sharedFolderOnly
                        case "other":
                            return Visibility.other
                        default:
                            return Visibility.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Metadata for a shared link. This can be either a PathLinkMetadata or CollectionLinkMetadata.
    */
    open class LinkMetadata: CustomStringConvertible {
        /// URL of the shared link.
        open let url : String
        /// Who can access the link.
        open let visibility : Sharing.Visibility
        /// Expiration time, if set. By default the link won't expire.
        open let expires : Date?
        public init(url: String, visibility: Sharing.Visibility, expires: Date? = nil) {
            stringValidator()(value: url)
            self.url = url
            self.visibility = visibility
            self.expires = expires
        }
        open var description : String {
            return "\(prepareJSONForSerialization(LinkMetadataSerializer().serialize(self)))"
        }
    }
    open class LinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LinkMetadata) -> JSON {
            var output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            switch value {
                case let path as Sharing.PathLinkMetadata:
                    for (k,v) in Serialization.getFields(Sharing.PathLinkMetadataSerializer().serialize(path)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("path")
                case let collection as Sharing.CollectionLinkMetadata:
                    for (k,v) in Serialization.getFields(Sharing.CollectionLinkMetadataSerializer().serialize(collection)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("collection")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "path":
                            return Sharing.PathLinkMetadataSerializer().deserialize(json)
                        case "collection":
                            return Sharing.CollectionLinkMetadataSerializer().deserialize(json)
                        default:
                            let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                            let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .null)
                            let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                            return LinkMetadata(url: url, visibility: visibility, expires: expires)
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Metadata for a path-based shared link.
    */
    open class PathLinkMetadata: Sharing.LinkMetadata {
        /// Path in user's Dropbox.
        open let path : String
        public init(url: String, visibility: Sharing.Visibility, path: String, expires: Date? = nil) {
            stringValidator()(value: path)
            self.path = path
            super.init(url: url, visibility: visibility, expires: expires)
        }
        open override var description : String {
            return "\(prepareJSONForSerialization(PathLinkMetadataSerializer().serialize(self)))"
        }
    }
    open class PathLinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PathLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "path": Serialization._StringSerializer.serialize(value.path),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PathLinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .null)
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                    return PathLinkMetadata(url: url, visibility: visibility, path: path, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Metadata for a collection-based shared link.
    */
    open class CollectionLinkMetadata: Sharing.LinkMetadata {
        open override var description : String {
            return "\(prepareJSONForSerialization(CollectionLinkMetadataSerializer().serialize(self)))"
        }
    }
    open class CollectionLinkMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CollectionLinkMetadata) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            "visibility": Sharing.VisibilitySerializer().serialize(value.visibility),
            "expires": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.expires),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CollectionLinkMetadata {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    let visibility = Sharing.VisibilitySerializer().deserialize(dict["visibility"] ?? .null)
                    let expires = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["expires"] ?? .null)
                    return CollectionLinkMetadata(url: url, visibility: visibility, expires: expires)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The GetSharedLinksArg struct
    */
    open class GetSharedLinksArg: CustomStringConvertible {
        /// See getSharedLinks description.
        open let path : String?
        public init(path: String? = nil) {
            nullableValidator(stringValidator())(value: path)
            self.path = path
        }
        open var description : String {
            return "\(prepareJSONForSerialization(GetSharedLinksArgSerializer().serialize(self)))"
        }
    }
    open class GetSharedLinksArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetSharedLinksArg) -> JSON {
            let output = [ 
            "path": NullableSerializer(Serialization._StringSerializer).serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetSharedLinksArg {
            switch json {
                case .dictionary(let dict):
                    let path = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path"] ?? .null)
                    return GetSharedLinksArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The GetSharedLinksResult struct
    */
    open class GetSharedLinksResult: CustomStringConvertible {
        /// Shared links applicable to the path argument.
        open let links : Array<Sharing.LinkMetadata>
        public init(links: Array<Sharing.LinkMetadata>) {
            self.links = links
        }
        open var description : String {
            return "\(prepareJSONForSerialization(GetSharedLinksResultSerializer().serialize(self)))"
        }
    }
    open class GetSharedLinksResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetSharedLinksResult) -> JSON {
            let output = [ 
            "links": ArraySerializer(Sharing.LinkMetadataSerializer()).serialize(value.links),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetSharedLinksResult {
            switch json {
                case .dictionary(let dict):
                    let links = ArraySerializer(Sharing.LinkMetadataSerializer()).deserialize(dict["links"] ?? .null)
                    return GetSharedLinksResult(links: links)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The GetSharedLinksError union
    */
    public enum GetSharedLinksError: CustomStringConvertible {
        case path(String?)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(GetSharedLinksErrorSerializer().serialize(self)))"
        }
    }
    open class GetSharedLinksErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetSharedLinksError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetSharedLinksError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["path"] ?? .null)
                            return GetSharedLinksError.path(v)
                        case "other":
                            return GetSharedLinksError.other
                        default:
                            return GetSharedLinksError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Flag to indicate pending upload default (for linking to not-yet-existing paths).
    */
    public enum PendingUploadMode: CustomStringConvertible {
        /**
            Assume pending uploads are files.
        */
        case file
        /**
            Assume pending uploads are folders.
        */
        case folder
        public var description : String {
            return "\(prepareJSONForSerialization(PendingUploadModeSerializer().serialize(self)))"
        }
    }
    open class PendingUploadModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PendingUploadMode) -> JSON {
            switch value {
                case .file:
                    var d = [String : JSON]()
                    d[".tag"] = .str("file")
                    return .dictionary(d)
                case .folder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("folder")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PendingUploadMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return PendingUploadMode.file
                        case "folder":
                            return PendingUploadMode.folder
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The CreateSharedLinkArg struct
    */
    open class CreateSharedLinkArg: CustomStringConvertible {
        /// The path to share.
        open let path : String
        /// Whether to return a shortened URL.
        open let shortUrl : Bool
        /// If it's okay to share a path that does not yet exist, set this to either file in PendingUploadMode or folder
        /// in PendingUploadMode to indicate whether to assume it's a file or folder.
        open let pendingUpload : Sharing.PendingUploadMode?
        public init(path: String, shortUrl: Bool = false, pendingUpload: Sharing.PendingUploadMode? = nil) {
            stringValidator()(value: path)
            self.path = path
            self.shortUrl = shortUrl
            self.pendingUpload = pendingUpload
        }
        open var description : String {
            return "\(prepareJSONForSerialization(CreateSharedLinkArgSerializer().serialize(self)))"
        }
    }
    open class CreateSharedLinkArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateSharedLinkArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "short_url": Serialization._BoolSerializer.serialize(value.shortUrl),
            "pending_upload": NullableSerializer(Sharing.PendingUploadModeSerializer()).serialize(value.pendingUpload),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateSharedLinkArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let shortUrl = Serialization._BoolSerializer.deserialize(dict["short_url"] ?? .null)
                    let pendingUpload = NullableSerializer(Sharing.PendingUploadModeSerializer()).deserialize(dict["pending_upload"] ?? .null)
                    return CreateSharedLinkArg(path: path, shortUrl: shortUrl, pendingUpload: pendingUpload)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The CreateSharedLinkError union
    */
    public enum CreateSharedLinkError: CustomStringConvertible {
        case path(Files.LookupError)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(CreateSharedLinkErrorSerializer().serialize(self)))"
        }
    }
    open class CreateSharedLinkErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateSharedLinkError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateSharedLinkError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return CreateSharedLinkError.path(v)
                        case "other":
                            return CreateSharedLinkError.other
                        default:
                            return CreateSharedLinkError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The RevokeSharedLinkArg struct
    */
    open class RevokeSharedLinkArg: CustomStringConvertible {
        /// URL of the shared link.
        open let url : String
        public init(url: String) {
            stringValidator()(value: url)
            self.url = url
        }
        open var description : String {
            return "\(prepareJSONForSerialization(RevokeSharedLinkArgSerializer().serialize(self)))"
        }
    }
    open class RevokeSharedLinkArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeSharedLinkArg) -> JSON {
            let output = [ 
            "url": Serialization._StringSerializer.serialize(value.url),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RevokeSharedLinkArg {
            switch json {
                case .dictionary(let dict):
                    let url = Serialization._StringSerializer.deserialize(dict["url"] ?? .null)
                    return RevokeSharedLinkArg(url: url)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The RevokeSharedLinkError union
    */
    public enum RevokeSharedLinkError: CustomStringConvertible {
        /**
            Shared link is malformed.
        */
        case sharedLinkMalformed
        /**
            Shared link not found.
        */
        case sharedLinkNotFound
        /**
            Shared link access denied.
        */
        case sharedLinkAccessDenied
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(RevokeSharedLinkErrorSerializer().serialize(self)))"
        }
    }
    open class RevokeSharedLinkErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RevokeSharedLinkError) -> JSON {
            switch value {
                case .sharedLinkMalformed:
                    var d = [String : JSON]()
                    d[".tag"] = .str("shared_link_malformed")
                    return .dictionary(d)
                case .sharedLinkNotFound:
                    var d = [String : JSON]()
                    d[".tag"] = .str("shared_link_not_found")
                    return .dictionary(d)
                case .sharedLinkAccessDenied:
                    var d = [String : JSON]()
                    d[".tag"] = .str("shared_link_access_denied")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RevokeSharedLinkError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "shared_link_malformed":
                            return RevokeSharedLinkError.sharedLinkMalformed
                        case "shared_link_not_found":
                            return RevokeSharedLinkError.sharedLinkNotFound
                        case "shared_link_access_denied":
                            return RevokeSharedLinkError.sharedLinkAccessDenied
                        case "other":
                            return RevokeSharedLinkError.other
                        default:
                            return RevokeSharedLinkError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Defines the access levels for collaborators.
    */
    public enum AccessLevel: CustomStringConvertible {
        /**
            The collaborator is the owner of the shared folder. Owners can view and edit the shared folder as well as
            set the folder's policies using updateFolderPolicy.
        */
        case owner
        /**
            The collaborator can both view and edit the shared folder.
        */
        case editor
        /**
            The collaborator can only view the shared folder.
        */
        case viewer
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(AccessLevelSerializer().serialize(self)))"
        }
    }
    open class AccessLevelSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AccessLevel) -> JSON {
            switch value {
                case .owner:
                    var d = [String : JSON]()
                    d[".tag"] = .str("owner")
                    return .dictionary(d)
                case .editor:
                    var d = [String : JSON]()
                    d[".tag"] = .str("editor")
                    return .dictionary(d)
                case .viewer:
                    var d = [String : JSON]()
                    d[".tag"] = .str("viewer")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AccessLevel {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "owner":
                            return AccessLevel.owner
                        case "editor":
                            return AccessLevel.editor
                        case "viewer":
                            return AccessLevel.viewer
                        case "other":
                            return AccessLevel.other
                        default:
                            return AccessLevel.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        A set of policies governing membership and privileges for a shared folder.
    */
    open class FolderPolicy: CustomStringConvertible {
        /// Who can be a member of this shared folder. Only set if the user is a member of a team.
        open let memberPolicy : Sharing.MemberPolicy?
        /// Who can add and remove members from this shared folder.
        open let aclUpdatePolicy : Sharing.AclUpdatePolicy
        /// Who links can be shared with.
        open let sharedLinkPolicy : Sharing.SharedLinkPolicy
        public init(aclUpdatePolicy: Sharing.AclUpdatePolicy, sharedLinkPolicy: Sharing.SharedLinkPolicy, memberPolicy: Sharing.MemberPolicy? = nil) {
            self.memberPolicy = memberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.sharedLinkPolicy = sharedLinkPolicy
        }
        open var description : String {
            return "\(prepareJSONForSerialization(FolderPolicySerializer().serialize(self)))"
        }
    }
    open class FolderPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FolderPolicy) -> JSON {
            let output = [ 
            "acl_update_policy": Sharing.AclUpdatePolicySerializer().serialize(value.aclUpdatePolicy),
            "shared_link_policy": Sharing.SharedLinkPolicySerializer().serialize(value.sharedLinkPolicy),
            "member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FolderPolicy {
            switch json {
                case .dictionary(let dict):
                    let aclUpdatePolicy = Sharing.AclUpdatePolicySerializer().deserialize(dict["acl_update_policy"] ?? .null)
                    let sharedLinkPolicy = Sharing.SharedLinkPolicySerializer().deserialize(dict["shared_link_policy"] ?? .null)
                    let memberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .null)
                    return FolderPolicy(aclUpdatePolicy: aclUpdatePolicy, sharedLinkPolicy: sharedLinkPolicy, memberPolicy: memberPolicy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Policy governing who can be a member of a shared folder. Only applicable to folders owned by a user on a team.
    */
    public enum MemberPolicy: CustomStringConvertible {
        /**
            Only a teammate can become a member.
        */
        case team
        /**
            Anyone can become a member.
        */
        case anyone
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(MemberPolicySerializer().serialize(self)))"
        }
    }
    open class MemberPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberPolicy) -> JSON {
            switch value {
                case .team:
                    var d = [String : JSON]()
                    d[".tag"] = .str("team")
                    return .dictionary(d)
                case .anyone:
                    var d = [String : JSON]()
                    d[".tag"] = .str("anyone")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MemberPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "team":
                            return MemberPolicy.team
                        case "anyone":
                            return MemberPolicy.anyone
                        case "other":
                            return MemberPolicy.other
                        default:
                            return MemberPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Policy governing who can change a shared folder's access control list (ACL). In other words, who can add,
        remove, or change the privileges of members.
    */
    public enum AclUpdatePolicy: CustomStringConvertible {
        /**
            Only the owner can update the ACL.
        */
        case owner
        /**
            Any editor can update the ACL. This may be further restricted to editors on the same team.
        */
        case editors
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(AclUpdatePolicySerializer().serialize(self)))"
        }
    }
    open class AclUpdatePolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AclUpdatePolicy) -> JSON {
            switch value {
                case .owner:
                    var d = [String : JSON]()
                    d[".tag"] = .str("owner")
                    return .dictionary(d)
                case .editors:
                    var d = [String : JSON]()
                    d[".tag"] = .str("editors")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AclUpdatePolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "owner":
                            return AclUpdatePolicy.owner
                        case "editors":
                            return AclUpdatePolicy.editors
                        case "other":
                            return AclUpdatePolicy.other
                        default:
                            return AclUpdatePolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Policy governing who can view shared links.
    */
    public enum SharedLinkPolicy: CustomStringConvertible {
        /**
            Links can be shared with anyone.
        */
        case anyone
        /**
            Links can only be shared among members of the shared folder.
        */
        case members
        /**
            An unknown shared link policy.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(SharedLinkPolicySerializer().serialize(self)))"
        }
    }
    open class SharedLinkPolicySerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedLinkPolicy) -> JSON {
            switch value {
                case .anyone:
                    var d = [String : JSON]()
                    d[".tag"] = .str("anyone")
                    return .dictionary(d)
                case .members:
                    var d = [String : JSON]()
                    d[".tag"] = .str("members")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedLinkPolicy {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "anyone":
                            return SharedLinkPolicy.anyone
                        case "members":
                            return SharedLinkPolicy.members
                        case "other":
                            return SharedLinkPolicy.other
                        default:
                            return SharedLinkPolicy.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The information about a member of the shared folder.
    */
    open class MembershipInfo: CustomStringConvertible {
        /// The access type for this member.
        open let accessType : Sharing.AccessLevel
        public init(accessType: Sharing.AccessLevel) {
            self.accessType = accessType
        }
        open var description : String {
            return "\(prepareJSONForSerialization(MembershipInfoSerializer().serialize(self)))"
        }
    }
    open class MembershipInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MembershipInfo {
            switch json {
                case .dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    return MembershipInfo(accessType: accessType)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Basic information about a user. Use usersAccount and usersAccountBatch` to obtain more detailed information.
    */
    open class UserInfo: CustomStringConvertible {
        /// The account ID of the user.
        open let accountId : String
        /// If the user is in the same team as current user.
        open let sameTeam : Bool
        /// The team member ID of the shared folder member. Only present if sameTeam is true.
        open let teamMemberId : String?
        public init(accountId: String, sameTeam: Bool, teamMemberId: String? = nil) {
            stringValidator(minLength: 40, maxLength: 40)(value: accountId)
            self.accountId = accountId
            self.sameTeam = sameTeam
            nullableValidator(stringValidator())(value: teamMemberId)
            self.teamMemberId = teamMemberId
        }
        open var description : String {
            return "\(prepareJSONForSerialization(UserInfoSerializer().serialize(self)))"
        }
    }
    open class UserInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserInfo) -> JSON {
            let output = [ 
            "account_id": Serialization._StringSerializer.serialize(value.accountId),
            "same_team": Serialization._BoolSerializer.serialize(value.sameTeam),
            "team_member_id": NullableSerializer(Serialization._StringSerializer).serialize(value.teamMemberId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserInfo {
            switch json {
                case .dictionary(let dict):
                    let accountId = Serialization._StringSerializer.deserialize(dict["account_id"] ?? .null)
                    let sameTeam = Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .null)
                    let teamMemberId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["team_member_id"] ?? .null)
                    return UserInfo(accountId: accountId, sameTeam: sameTeam, teamMemberId: teamMemberId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The information about a user member of the shared folder.
    */
    open class UserMembershipInfo: Sharing.MembershipInfo {
        /// The account information for the membership user.
        open let user : Sharing.UserInfo
        public init(accessType: Sharing.AccessLevel, user: Sharing.UserInfo) {
            self.user = user
            super.init(accessType: accessType)
        }
        open override var description : String {
            return "\(prepareJSONForSerialization(UserMembershipInfoSerializer().serialize(self)))"
        }
    }
    open class UserMembershipInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "user": Sharing.UserInfoSerializer().serialize(value.user),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserMembershipInfo {
            switch json {
                case .dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    let user = Sharing.UserInfoSerializer().deserialize(dict["user"] ?? .null)
                    return UserMembershipInfo(accessType: accessType, user: user)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The information about a user invited to become a member a shared folder.
    */
    public enum InviteeInfo: CustomStringConvertible {
        /**
            E-mail address of invited user.
        */
        case email(String)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(InviteeInfoSerializer().serialize(self)))"
        }
    }
    open class InviteeInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: InviteeInfo) -> JSON {
            switch value {
                case .email(let arg):
                    var d = ["email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("email")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> InviteeInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email":
                            let v = Serialization._StringSerializer.deserialize(d["email"] ?? .null)
                            return InviteeInfo.email(v)
                        case "other":
                            return InviteeInfo.other
                        default:
                            return InviteeInfo.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The information about a user invited to become a member of a shared folder.
    */
    open class InviteeMembershipInfo: Sharing.MembershipInfo {
        /// The information for the invited user.
        open let invitee : Sharing.InviteeInfo
        public init(accessType: Sharing.AccessLevel, invitee: Sharing.InviteeInfo) {
            self.invitee = invitee
            super.init(accessType: accessType)
        }
        open override var description : String {
            return "\(prepareJSONForSerialization(InviteeMembershipInfoSerializer().serialize(self)))"
        }
    }
    open class InviteeMembershipInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: InviteeMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "invitee": Sharing.InviteeInfoSerializer().serialize(value.invitee),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> InviteeMembershipInfo {
            switch json {
                case .dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    let invitee = Sharing.InviteeInfoSerializer().deserialize(dict["invitee"] ?? .null)
                    return InviteeMembershipInfo(accessType: accessType, invitee: invitee)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The information about a group. Groups is a way to manage a list of users  who need same access permission to the
        shared folder.
    */
    open class GroupInfo: Team.GroupSummary {
        /// If the group is owned by the current user's team.
        open let sameTeam : Bool
        public init(groupName: String, groupId: String, memberCount: UInt32, sameTeam: Bool, groupExternalId: String? = nil) {
            self.sameTeam = sameTeam
            super.init(groupName: groupName, groupId: groupId, memberCount: memberCount, groupExternalId: groupExternalId)
        }
        open override var description : String {
            return "\(prepareJSONForSerialization(GroupInfoSerializer().serialize(self)))"
        }
    }
    open class GroupInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupInfo) -> JSON {
            let output = [ 
            "group_name": Serialization._StringSerializer.serialize(value.groupName),
            "group_id": Serialization._StringSerializer.serialize(value.groupId),
            "member_count": Serialization._UInt32Serializer.serialize(value.memberCount),
            "same_team": Serialization._BoolSerializer.serialize(value.sameTeam),
            "group_external_id": NullableSerializer(Serialization._StringSerializer).serialize(value.groupExternalId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupInfo {
            switch json {
                case .dictionary(let dict):
                    let groupName = Serialization._StringSerializer.deserialize(dict["group_name"] ?? .null)
                    let groupId = Serialization._StringSerializer.deserialize(dict["group_id"] ?? .null)
                    let memberCount = Serialization._UInt32Serializer.deserialize(dict["member_count"] ?? .null)
                    let sameTeam = Serialization._BoolSerializer.deserialize(dict["same_team"] ?? .null)
                    let groupExternalId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["group_external_id"] ?? .null)
                    return GroupInfo(groupName: groupName, groupId: groupId, memberCount: memberCount, sameTeam: sameTeam, groupExternalId: groupExternalId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The information about a group member of the shared folder.
    */
    open class GroupMembershipInfo: Sharing.MembershipInfo {
        /// The information about the membership group.
        open let group : Sharing.GroupInfo
        public init(accessType: Sharing.AccessLevel, group: Sharing.GroupInfo) {
            self.group = group
            super.init(accessType: accessType)
        }
        open override var description : String {
            return "\(prepareJSONForSerialization(GroupMembershipInfoSerializer().serialize(self)))"
        }
    }
    open class GroupMembershipInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GroupMembershipInfo) -> JSON {
            let output = [ 
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "group": Sharing.GroupInfoSerializer().serialize(value.group),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GroupMembershipInfo {
            switch json {
                case .dictionary(let dict):
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    let group = Sharing.GroupInfoSerializer().deserialize(dict["group"] ?? .null)
                    return GroupMembershipInfo(accessType: accessType, group: group)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The metadata which includes basic information about the shared folder.
    */
    open class SharedFolderMetadata: CustomStringConvertible {
        /// The lower-cased full path of this shared folder. Absent for unmounted folders.
        open let pathLower : String?
        /// The name of the this shared folder.
        open let name : String
        /// The ID of the shared folder.
        open let sharedFolderId : String
        /// The current user's access level for this shared folder.
        open let accessType : Sharing.AccessLevel
        /// Whether this folder is a team folder https://www.dropbox.com/en/help/986.
        open let isTeamFolder : Bool
        /// Policies governing this shared folder.
        open let policy : Sharing.FolderPolicy
        public init(name: String, sharedFolderId: String, accessType: Sharing.AccessLevel, isTeamFolder: Bool, policy: Sharing.FolderPolicy, pathLower: String? = nil) {
            nullableValidator(stringValidator())(value: pathLower)
            self.pathLower = pathLower
            stringValidator()(value: name)
            self.name = name
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.accessType = accessType
            self.isTeamFolder = isTeamFolder
            self.policy = policy
        }
        open var description : String {
            return "\(prepareJSONForSerialization(SharedFolderMetadataSerializer().serialize(self)))"
        }
    }
    open class SharedFolderMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "access_type": Sharing.AccessLevelSerializer().serialize(value.accessType),
            "is_team_folder": Serialization._BoolSerializer.serialize(value.isTeamFolder),
            "policy": Sharing.FolderPolicySerializer().serialize(value.policy),
            "path_lower": NullableSerializer(Serialization._StringSerializer).serialize(value.pathLower),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let accessType = Sharing.AccessLevelSerializer().deserialize(dict["access_type"] ?? .null)
                    let isTeamFolder = Serialization._BoolSerializer.deserialize(dict["is_team_folder"] ?? .null)
                    let policy = Sharing.FolderPolicySerializer().deserialize(dict["policy"] ?? .null)
                    let pathLower = NullableSerializer(Serialization._StringSerializer).deserialize(dict["path_lower"] ?? .null)
                    return SharedFolderMetadata(name: name, sharedFolderId: sharedFolderId, accessType: accessType, isTeamFolder: isTeamFolder, policy: policy, pathLower: pathLower)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        There is an error accessing the shared folder.
    */
    public enum SharedFolderAccessError: CustomStringConvertible {
        /**
            This shared folder ID is invalid.
        */
        case invalidId
        /**
            The user is not a member of the shared folder thus cannot access it.
        */
        case notAMember
        /**
            The current user does not have sufficient privileges to perform the desired action.
        */
        case noPermission
        /**
            The current account's e-mail address is unverified.
        */
        case emailUnverified
        /**
            The current user cannot perform this action on a team shared folder.
        */
        case teamFolder
        /**
            The shared folder is unmounted.
        */
        case unmounted
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(SharedFolderAccessErrorSerializer().serialize(self)))"
        }
    }
    open class SharedFolderAccessErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderAccessError) -> JSON {
            switch value {
                case .invalidId:
                    var d = [String : JSON]()
                    d[".tag"] = .str("invalid_id")
                    return .dictionary(d)
                case .notAMember:
                    var d = [String : JSON]()
                    d[".tag"] = .str("not_a_member")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String : JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String : JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .teamFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("team_folder")
                    return .dictionary(d)
                case .unmounted:
                    var d = [String : JSON]()
                    d[".tag"] = .str("unmounted")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedFolderAccessError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_id":
                            return SharedFolderAccessError.invalidId
                        case "not_a_member":
                            return SharedFolderAccessError.notAMember
                        case "no_permission":
                            return SharedFolderAccessError.noPermission
                        case "email_unverified":
                            return SharedFolderAccessError.emailUnverified
                        case "team_folder":
                            return SharedFolderAccessError.teamFolder
                        case "unmounted":
                            return SharedFolderAccessError.unmounted
                        case "other":
                            return SharedFolderAccessError.other
                        default:
                            return SharedFolderAccessError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Result for listFolders. Unmounted shared folders can be identified by the absence of pathLower in
        SharedFolderMetadata.
    */
    open class ListFoldersResult: CustomStringConvertible {
        /// List of all shared folders the authenticated user has access to.
        open let entries : Array<Sharing.SharedFolderMetadata>
        /// Present if there are additional shared folders that have not been returned yet. Pass the cursor into
        /// listFoldersContinue to list additional folders.
        open let cursor : String?
        public init(entries: Array<Sharing.SharedFolderMetadata>, cursor: String? = nil) {
            self.entries = entries
            nullableValidator(stringValidator())(value: cursor)
            self.cursor = cursor
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListFoldersResultSerializer().serialize(self)))"
        }
    }
    open class ListFoldersResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFoldersResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Sharing.SharedFolderMetadataSerializer()).serialize(value.entries),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFoldersResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Sharing.SharedFolderMetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return ListFoldersResult(entries: entries, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFoldersContinueArg struct
    */
    open class ListFoldersContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to listFolders or listFoldersContinue.
        open let cursor : String
        public init(cursor: String) {
            stringValidator()(value: cursor)
            self.cursor = cursor
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListFoldersContinueArgSerializer().serialize(self)))"
        }
    }
    open class ListFoldersContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFoldersContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFoldersContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFoldersContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFoldersContinueError union
    */
    public enum ListFoldersContinueError: CustomStringConvertible {
        /**
            cursor in ListFoldersContinueArg is invalid.
        */
        case invalidCursor
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFoldersContinueErrorSerializer().serialize(self)))"
        }
    }
    open class ListFoldersContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFoldersContinueError) -> JSON {
            switch value {
                case .invalidCursor:
                    var d = [String : JSON]()
                    d[".tag"] = .str("invalid_cursor")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFoldersContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_cursor":
                            return ListFoldersContinueError.invalidCursor
                        case "other":
                            return ListFoldersContinueError.other
                        default:
                            return ListFoldersContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The GetMetadataArgs struct
    */
    open class GetMetadataArgs: CustomStringConvertible {
        /// The ID for the shared folder.
        open let sharedFolderId : String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        open var description : String {
            return "\(prepareJSONForSerialization(GetMetadataArgsSerializer().serialize(self)))"
        }
    }
    open class GetMetadataArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataArgs) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetMetadataArgs {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    return GetMetadataArgs(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderMembersArgs struct
    */
    open class ListFolderMembersArgs: CustomStringConvertible {
        /// The ID for the shared folder.
        open let sharedFolderId : String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListFolderMembersArgsSerializer().serialize(self)))"
        }
    }
    open class ListFolderMembersArgsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderMembersArgs) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderMembersArgs {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    return ListFolderMembersArgs(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Shared folder user and group membership.
    */
    open class SharedFolderMembers: CustomStringConvertible {
        /// The list of user members of the shared folder.
        open let users : Array<Sharing.UserMembershipInfo>
        /// The list of group members of the shared folder.
        open let groups : Array<Sharing.GroupMembershipInfo>
        /// The list of invited members of the shared folder. This list will not include invitees that have already
        /// accepted or declined to join the shared folder.
        open let invitees : Array<Sharing.InviteeMembershipInfo>
        /// Present if there are additional shared folder members that have not been returned yet. Pass the cursor into
        /// listFolderMembersContinue to list additional members.
        open let cursor : String?
        public init(users: Array<Sharing.UserMembershipInfo>, groups: Array<Sharing.GroupMembershipInfo>, invitees: Array<Sharing.InviteeMembershipInfo>, cursor: String? = nil) {
            self.users = users
            self.groups = groups
            self.invitees = invitees
            nullableValidator(stringValidator())(value: cursor)
            self.cursor = cursor
        }
        open var description : String {
            return "\(prepareJSONForSerialization(SharedFolderMembersSerializer().serialize(self)))"
        }
    }
    open class SharedFolderMembersSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderMembers) -> JSON {
            let output = [ 
            "users": ArraySerializer(Sharing.UserMembershipInfoSerializer()).serialize(value.users),
            "groups": ArraySerializer(Sharing.GroupMembershipInfoSerializer()).serialize(value.groups),
            "invitees": ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).serialize(value.invitees),
            "cursor": NullableSerializer(Serialization._StringSerializer).serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SharedFolderMembers {
            switch json {
                case .dictionary(let dict):
                    let users = ArraySerializer(Sharing.UserMembershipInfoSerializer()).deserialize(dict["users"] ?? .null)
                    let groups = ArraySerializer(Sharing.GroupMembershipInfoSerializer()).deserialize(dict["groups"] ?? .null)
                    let invitees = ArraySerializer(Sharing.InviteeMembershipInfoSerializer()).deserialize(dict["invitees"] ?? .null)
                    let cursor = NullableSerializer(Serialization._StringSerializer).deserialize(dict["cursor"] ?? .null)
                    return SharedFolderMembers(users: users, groups: groups, invitees: invitees, cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderMembersContinueArg struct
    */
    open class ListFolderMembersContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to listFolderMembers or listFolderMembersContinue.
        open let cursor : String
        public init(cursor: String) {
            stringValidator()(value: cursor)
            self.cursor = cursor
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListFolderMembersContinueArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderMembersContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderMembersContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderMembersContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderMembersContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderMembersContinueError union
    */
    public enum ListFolderMembersContinueError: CustomStringConvertible {
        case accessError(Sharing.SharedFolderAccessError)
        /**
            cursor in ListFolderMembersContinueArg is invalid.
        */
        case invalidCursor
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderMembersContinueErrorSerializer().serialize(self)))"
        }
    }
    open class ListFolderMembersContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderMembersContinueError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .invalidCursor:
                    var d = [String : JSON]()
                    d[".tag"] = .str("invalid_cursor")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFolderMembersContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return ListFolderMembersContinueError.accessError(v)
                        case "invalid_cursor":
                            return ListFolderMembersContinueError.invalidCursor
                        case "other":
                            return ListFolderMembersContinueError.other
                        default:
                            return ListFolderMembersContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ShareFolderArg struct
    */
    open class ShareFolderArg: CustomStringConvertible {
        /// The path to the folder to share. If it does not exist, then a new one is created.
        open let path : String
        /// Who can be a member of this shared folder.
        open let memberPolicy : Sharing.MemberPolicy
        /// Who can add and remove members of this shared folder.
        open let aclUpdatePolicy : Sharing.AclUpdatePolicy
        /// The policy to apply to shared links created for content inside this shared folder.
        open let sharedLinkPolicy : Sharing.SharedLinkPolicy
        /// Whether to force the share to happen asynchronously.
        open let forceAsync : Bool
        public init(path: String, memberPolicy: Sharing.MemberPolicy = .anyone, aclUpdatePolicy: Sharing.AclUpdatePolicy = .owner, sharedLinkPolicy: Sharing.SharedLinkPolicy = .anyone, forceAsync: Bool = false) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
            self.memberPolicy = memberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.sharedLinkPolicy = sharedLinkPolicy
            self.forceAsync = forceAsync
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ShareFolderArgSerializer().serialize(self)))"
        }
    }
    open class ShareFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShareFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "member_policy": Sharing.MemberPolicySerializer().serialize(value.memberPolicy),
            "acl_update_policy": Sharing.AclUpdatePolicySerializer().serialize(value.aclUpdatePolicy),
            "shared_link_policy": Sharing.SharedLinkPolicySerializer().serialize(value.sharedLinkPolicy),
            "force_async": Serialization._BoolSerializer.serialize(value.forceAsync),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ShareFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let memberPolicy = Sharing.MemberPolicySerializer().deserialize(dict["member_policy"] ?? .null)
                    let aclUpdatePolicy = Sharing.AclUpdatePolicySerializer().deserialize(dict["acl_update_policy"] ?? .null)
                    let sharedLinkPolicy = Sharing.SharedLinkPolicySerializer().deserialize(dict["shared_link_policy"] ?? .null)
                    let forceAsync = Serialization._BoolSerializer.deserialize(dict["force_async"] ?? .null)
                    return ShareFolderArg(path: path, memberPolicy: memberPolicy, aclUpdatePolicy: aclUpdatePolicy, sharedLinkPolicy: sharedLinkPolicy, forceAsync: forceAsync)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ShareFolderError union
    */
    public enum ShareFolderError: CustomStringConvertible {
        /**
            The current account's e-mail address is unverified.
        */
        case emailUnverified
        /**
            path in ShareFolderArg is invalid.
        */
        case badPath(Sharing.SharePathError)
        /**
            Team policy is more restrictive than memberPolicy in ShareFolderArg.
        */
        case teamPolicyDisallowsMemberPolicy
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(ShareFolderErrorSerializer().serialize(self)))"
        }
    }
    open class ShareFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShareFolderError) -> JSON {
            switch value {
                case .emailUnverified:
                    var d = [String : JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .badPath(let arg):
                    var d = ["bad_path": Sharing.SharePathErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("bad_path")
                    return .dictionary(d)
                case .teamPolicyDisallowsMemberPolicy:
                    var d = [String : JSON]()
                    d[".tag"] = .str("team_policy_disallows_member_policy")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ShareFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "email_unverified":
                            return ShareFolderError.emailUnverified
                        case "bad_path":
                            let v = Sharing.SharePathErrorSerializer().deserialize(d["bad_path"] ?? .null)
                            return ShareFolderError.badPath(v)
                        case "team_policy_disallows_member_policy":
                            return ShareFolderError.teamPolicyDisallowsMemberPolicy
                        case "other":
                            return ShareFolderError.other
                        default:
                            return ShareFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The SharePathError union
    */
    public enum SharePathError: CustomStringConvertible {
        /**
            A file is at the specified path.
        */
        case isFile
        /**
            We do not support sharing a folder inside a shared folder.
        */
        case insideSharedFolder
        /**
            We do not support shared folders that contain shared folders.
        */
        case containsSharedFolder
        /**
            We do not support sharing an app folder.
        */
        case isAppFolder
        /**
            We do not support sharing a folder inside an app folder.
        */
        case insideAppFolder
        /**
            Folder is already shared.
        */
        case alreadyShared
        /**
            Path is not valid.
        */
        case invalidPath
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(SharePathErrorSerializer().serialize(self)))"
        }
    }
    open class SharePathErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharePathError) -> JSON {
            switch value {
                case .isFile:
                    var d = [String : JSON]()
                    d[".tag"] = .str("is_file")
                    return .dictionary(d)
                case .insideSharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("inside_shared_folder")
                    return .dictionary(d)
                case .containsSharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("contains_shared_folder")
                    return .dictionary(d)
                case .isAppFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("is_app_folder")
                    return .dictionary(d)
                case .insideAppFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("inside_app_folder")
                    return .dictionary(d)
                case .alreadyShared:
                    var d = [String : JSON]()
                    d[".tag"] = .str("already_shared")
                    return .dictionary(d)
                case .invalidPath:
                    var d = [String : JSON]()
                    d[".tag"] = .str("invalid_path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharePathError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "is_file":
                            return SharePathError.isFile
                        case "inside_shared_folder":
                            return SharePathError.insideSharedFolder
                        case "contains_shared_folder":
                            return SharePathError.containsSharedFolder
                        case "is_app_folder":
                            return SharePathError.isAppFolder
                        case "inside_app_folder":
                            return SharePathError.insideAppFolder
                        case "already_shared":
                            return SharePathError.alreadyShared
                        case "invalid_path":
                            return SharePathError.invalidPath
                        case "other":
                            return SharePathError.other
                        default:
                            return SharePathError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ShareFolderJobStatus union
    */
    public enum ShareFolderJobStatus: CustomStringConvertible {
        /**
            The share job has finished. The value is the metadata for the folder.
        */
        case complete(Sharing.SharedFolderMetadata)
        case failed(Sharing.ShareFolderError)
        public var description : String {
            return "\(prepareJSONForSerialization(ShareFolderJobStatusSerializer().serialize(self)))"
        }
    }
    open class ShareFolderJobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShareFolderJobStatus) -> JSON {
            switch value {
                case .complete(let arg):
                    var d = Serialization.getFields(Sharing.SharedFolderMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Sharing.ShareFolderErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ShareFolderJobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "complete":
                            let v = Sharing.SharedFolderMetadataSerializer().deserialize(json)
                            return ShareFolderJobStatus.complete(v)
                        case "failed":
                            let v = Sharing.ShareFolderErrorSerializer().deserialize(d["failed"] ?? .null)
                            return ShareFolderJobStatus.failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ShareFolderLaunch union
    */
    public enum ShareFolderLaunch: CustomStringConvertible {
        case complete(Sharing.SharedFolderMetadata)
        public var description : String {
            return "\(prepareJSONForSerialization(ShareFolderLaunchSerializer().serialize(self)))"
        }
    }
    open class ShareFolderLaunchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ShareFolderLaunch) -> JSON {
            switch value {
                case .complete(let arg):
                    var d = Serialization.getFields(Sharing.SharedFolderMetadataSerializer().serialize(arg))
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ShareFolderLaunch {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "complete":
                            let v = Sharing.SharedFolderMetadataSerializer().deserialize(json)
                            return ShareFolderLaunch.complete(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The JobStatus union
    */
    public enum JobStatus: CustomStringConvertible {
        /**
            The asynchronous job has finished.
        */
        case complete
        /**
            The asynchronous job returned an error.
        */
        case failed(Sharing.JobError)
        public var description : String {
            return "\(prepareJSONForSerialization(JobStatusSerializer().serialize(self)))"
        }
    }
    open class JobStatusSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: JobStatus) -> JSON {
            switch value {
                case .complete:
                    var d = [String : JSON]()
                    d[".tag"] = .str("complete")
                    return .dictionary(d)
                case .failed(let arg):
                    var d = ["failed": Sharing.JobErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("failed")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> JobStatus {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "complete":
                            return JobStatus.complete
                        case "failed":
                            let v = Sharing.JobErrorSerializer().deserialize(d["failed"] ?? .null)
                            return JobStatus.failed(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The SharedFolderMemberError union
    */
    public enum SharedFolderMemberError: CustomStringConvertible {
        /**
            The target dropbox_id is invalid.
        */
        case invalidDropboxId
        /**
            The target dropbox_id is not a member of the shared folder.
        */
        case notAMember
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(SharedFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    open class SharedFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SharedFolderMemberError) -> JSON {
            switch value {
                case .invalidDropboxId:
                    var d = [String : JSON]()
                    d[".tag"] = .str("invalid_dropbox_id")
                    return .dictionary(d)
                case .notAMember:
                    var d = [String : JSON]()
                    d[".tag"] = .str("not_a_member")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SharedFolderMemberError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_dropbox_id":
                            return SharedFolderMemberError.invalidDropboxId
                        case "not_a_member":
                            return SharedFolderMemberError.notAMember
                        case "other":
                            return SharedFolderMemberError.other
                        default:
                            return SharedFolderMemberError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The JobError union
    */
    public enum JobError: CustomStringConvertible {
        case accessError(Sharing.SharedFolderAccessError)
        case memberError(Sharing.SharedFolderMemberError)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(JobErrorSerializer().serialize(self)))"
        }
    }
    open class JobErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: JobError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .memberError(let arg):
                    var d = ["member_error": Sharing.SharedFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("member_error")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> JobError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return JobError.accessError(v)
                        case "member_error":
                            let v = Sharing.SharedFolderMemberErrorSerializer().deserialize(d["member_error"] ?? .null)
                            return JobError.memberError(v)
                        case "other":
                            return JobError.other
                        default:
                            return JobError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UnshareFolderArg struct
    */
    open class UnshareFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        open let sharedFolderId : String
        /// If true, members of this shared folder will get a copy of this folder after it's unshared. Otherwise, it
        /// will be removed from their Dropbox. The current user, who is an owner, will always retain their copy.
        open let leaveACopy : Bool
        public init(sharedFolderId: String, leaveACopy: Bool) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.leaveACopy = leaveACopy
        }
        open var description : String {
            return "\(prepareJSONForSerialization(UnshareFolderArgSerializer().serialize(self)))"
        }
    }
    open class UnshareFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnshareFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "leave_a_copy": Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UnshareFolderArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let leaveACopy = Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .null)
                    return UnshareFolderArg(sharedFolderId: sharedFolderId, leaveACopy: leaveACopy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UnshareFolderError union
    */
    public enum UnshareFolderError: CustomStringConvertible {
        case accessError(Sharing.SharedFolderAccessError)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(UnshareFolderErrorSerializer().serialize(self)))"
        }
    }
    open class UnshareFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnshareFolderError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UnshareFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return UnshareFolderError.accessError(v)
                        case "other":
                            return UnshareFolderError.other
                        default:
                            return UnshareFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The TransferFolderArg struct
    */
    open class TransferFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        open let sharedFolderId : String
        /// A account or team member ID to transfer ownership to.
        open let toDropboxId : String
        public init(sharedFolderId: String, toDropboxId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            stringValidator(minLength: 1)(value: toDropboxId)
            self.toDropboxId = toDropboxId
        }
        open var description : String {
            return "\(prepareJSONForSerialization(TransferFolderArgSerializer().serialize(self)))"
        }
    }
    open class TransferFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TransferFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "to_dropbox_id": Serialization._StringSerializer.serialize(value.toDropboxId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> TransferFolderArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let toDropboxId = Serialization._StringSerializer.deserialize(dict["to_dropbox_id"] ?? .null)
                    return TransferFolderArg(sharedFolderId: sharedFolderId, toDropboxId: toDropboxId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The TransferFolderError union
    */
    public enum TransferFolderError: CustomStringConvertible {
        case accessError(Sharing.SharedFolderAccessError)
        /**
            The current account does not have permission to perform this action.
        */
        case noPermission
        /**
            toDropboxId in TransferFolderArg is invalid.
        */
        case invalidDropboxId
        /**
            The new designated owner is not currently a member of the shared folder.
        */
        case newOwnerNotAMember
        /**
            The new desginated owner does not have the shared folder mounted.
        */
        case newOwnerUnmounted
        /**
            The new designated owner's e-mail address is unverified.
        */
        case newOwnerEmailUnverified
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(TransferFolderErrorSerializer().serialize(self)))"
        }
    }
    open class TransferFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: TransferFolderError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String : JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .invalidDropboxId:
                    var d = [String : JSON]()
                    d[".tag"] = .str("invalid_dropbox_id")
                    return .dictionary(d)
                case .newOwnerNotAMember:
                    var d = [String : JSON]()
                    d[".tag"] = .str("new_owner_not_a_member")
                    return .dictionary(d)
                case .newOwnerUnmounted:
                    var d = [String : JSON]()
                    d[".tag"] = .str("new_owner_unmounted")
                    return .dictionary(d)
                case .newOwnerEmailUnverified:
                    var d = [String : JSON]()
                    d[".tag"] = .str("new_owner_email_unverified")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> TransferFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return TransferFolderError.accessError(v)
                        case "no_permission":
                            return TransferFolderError.noPermission
                        case "invalid_dropbox_id":
                            return TransferFolderError.invalidDropboxId
                        case "new_owner_not_a_member":
                            return TransferFolderError.newOwnerNotAMember
                        case "new_owner_unmounted":
                            return TransferFolderError.newOwnerUnmounted
                        case "new_owner_email_unverified":
                            return TransferFolderError.newOwnerEmailUnverified
                        case "other":
                            return TransferFolderError.other
                        default:
                            return TransferFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        If any of the policy's are unset, then they retain their current setting.
    */
    open class UpdateFolderPolicyArg: CustomStringConvertible {
        /// The ID for the shared folder.
        open let sharedFolderId : String
        /// Who can be a member of this shared folder. Only set this if the current user is on a team.
        open let memberPolicy : Sharing.MemberPolicy?
        /// Who can add and remove members of this shared folder.
        open let aclUpdatePolicy : Sharing.AclUpdatePolicy?
        /// The policy to apply to shared links created for content inside this shared folder.
        open let sharedLinkPolicy : Sharing.SharedLinkPolicy?
        public init(sharedFolderId: String, memberPolicy: Sharing.MemberPolicy? = nil, aclUpdatePolicy: Sharing.AclUpdatePolicy? = nil, sharedLinkPolicy: Sharing.SharedLinkPolicy? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.memberPolicy = memberPolicy
            self.aclUpdatePolicy = aclUpdatePolicy
            self.sharedLinkPolicy = sharedLinkPolicy
        }
        open var description : String {
            return "\(prepareJSONForSerialization(UpdateFolderPolicyArgSerializer().serialize(self)))"
        }
    }
    open class UpdateFolderPolicyArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFolderPolicyArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member_policy": NullableSerializer(Sharing.MemberPolicySerializer()).serialize(value.memberPolicy),
            "acl_update_policy": NullableSerializer(Sharing.AclUpdatePolicySerializer()).serialize(value.aclUpdatePolicy),
            "shared_link_policy": NullableSerializer(Sharing.SharedLinkPolicySerializer()).serialize(value.sharedLinkPolicy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdateFolderPolicyArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let memberPolicy = NullableSerializer(Sharing.MemberPolicySerializer()).deserialize(dict["member_policy"] ?? .null)
                    let aclUpdatePolicy = NullableSerializer(Sharing.AclUpdatePolicySerializer()).deserialize(dict["acl_update_policy"] ?? .null)
                    let sharedLinkPolicy = NullableSerializer(Sharing.SharedLinkPolicySerializer()).deserialize(dict["shared_link_policy"] ?? .null)
                    return UpdateFolderPolicyArg(sharedFolderId: sharedFolderId, memberPolicy: memberPolicy, aclUpdatePolicy: aclUpdatePolicy, sharedLinkPolicy: sharedLinkPolicy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UpdateFolderPolicyError union
    */
    public enum UpdateFolderPolicyError: CustomStringConvertible {
        case accessError(Sharing.SharedFolderAccessError)
        /**
            memberPolicy in UpdateFolderPolicyArg was set even though user is not on a team.
        */
        case notOnTeam
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(UpdateFolderPolicyErrorSerializer().serialize(self)))"
        }
    }
    open class UpdateFolderPolicyErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFolderPolicyError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .notOnTeam:
                    var d = [String : JSON]()
                    d[".tag"] = .str("not_on_team")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UpdateFolderPolicyError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return UpdateFolderPolicyError.accessError(v)
                        case "not_on_team":
                            return UpdateFolderPolicyError.notOnTeam
                        case "other":
                            return UpdateFolderPolicyError.other
                        default:
                            return UpdateFolderPolicyError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The AddFolderMemberArg struct
    */
    open class AddFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        open let sharedFolderId : String
        /// The intended list of members to add.  Added members will receive invites to join the shared folder.
        open let members : Array<Sharing.AddMember>
        /// Whether added members should be notified via email and device notifications of their invite.
        open let quiet : Bool
        /// Optional message to display to added members in their invitation.
        open let customMessage : String?
        public init(sharedFolderId: String, members: Array<Sharing.AddMember>, quiet: Bool = false, customMessage: String? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.members = members
            self.quiet = quiet
            nullableValidator(stringValidator(minLength: 1))(value: customMessage)
            self.customMessage = customMessage
        }
        open var description : String {
            return "\(prepareJSONForSerialization(AddFolderMemberArgSerializer().serialize(self)))"
        }
    }
    open class AddFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "members": ArraySerializer(Sharing.AddMemberSerializer()).serialize(value.members),
            "quiet": Serialization._BoolSerializer.serialize(value.quiet),
            "custom_message": NullableSerializer(Serialization._StringSerializer).serialize(value.customMessage),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AddFolderMemberArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let members = ArraySerializer(Sharing.AddMemberSerializer()).deserialize(dict["members"] ?? .null)
                    let quiet = Serialization._BoolSerializer.deserialize(dict["quiet"] ?? .null)
                    let customMessage = NullableSerializer(Serialization._StringSerializer).deserialize(dict["custom_message"] ?? .null)
                    return AddFolderMemberArg(sharedFolderId: sharedFolderId, members: members, quiet: quiet, customMessage: customMessage)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The member and type of access the member should have when added to a shared folder.
    */
    open class AddMember: CustomStringConvertible {
        /// The member to add to the shared folder.
        open let member : Sharing.MemberSelector
        /// The access level to grant member to the shared folder.  owner in AccessLevel is disallowed.
        open let accessLevel : Sharing.AccessLevel
        public init(member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel = .viewer) {
            self.member = member
            self.accessLevel = accessLevel
        }
        open var description : String {
            return "\(prepareJSONForSerialization(AddMemberSerializer().serialize(self)))"
        }
    }
    open class AddMemberSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddMember) -> JSON {
            let output = [ 
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> AddMember {
            switch json {
                case .dictionary(let dict):
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .null)
                    return AddMember(member: member, accessLevel: accessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Includes different ways to identify a member of a shared folder.
    */
    public enum MemberSelector: CustomStringConvertible {
        /**
            Dropbox account, team member, or group ID of member.
        */
        case dropboxId(String)
        /**
            E-mail address of member.
        */
        case email(String)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(MemberSelectorSerializer().serialize(self)))"
        }
    }
    open class MemberSelectorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MemberSelector) -> JSON {
            switch value {
                case .dropboxId(let arg):
                    var d = ["dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("dropbox_id")
                    return .dictionary(d)
                case .email(let arg):
                    var d = ["email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("email")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MemberSelector {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["dropbox_id"] ?? .null)
                            return MemberSelector.dropboxId(v)
                        case "email":
                            let v = Serialization._StringSerializer.deserialize(d["email"] ?? .null)
                            return MemberSelector.email(v)
                        case "other":
                            return MemberSelector.other
                        default:
                            return MemberSelector.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The AddFolderMemberError union
    */
    public enum AddFolderMemberError: CustomStringConvertible {
        /**
            Unable to access shared folder.
        */
        case accessError(Sharing.SharedFolderAccessError)
        /**
            The current account's e-mail address is unverified.
        */
        case emailUnverified
        /**
            members in AddFolderMemberArg contains a bad invitation recipient.
        */
        case badMember(Sharing.AddMemberSelectorError)
        /**
            The current account does not have permission to perform this action.
        */
        case noPermission
        /**
            Your team policy does not allow sharing outside of the team.
        */
        case cantShareOutsideTeam
        /**
            The value is the member limit that was reached.
        */
        case tooManyMembers(UInt64)
        /**
            The value is the pending invite limit that was reached.
        */
        case tooManyPendingInvites(UInt64)
        /**
            The user has reached the rate limit for invitations.
        */
        case rateLimit
        /**
            The current user's account doesn't support this action. An example of this is when adding a read-only
            member. This action can only be performed by users that have upgraded to a Pro or Business plan.
        */
        case insufficientPlan
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(AddFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    open class AddFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddFolderMemberError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .emailUnverified:
                    var d = [String : JSON]()
                    d[".tag"] = .str("email_unverified")
                    return .dictionary(d)
                case .badMember(let arg):
                    var d = ["bad_member": Sharing.AddMemberSelectorErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("bad_member")
                    return .dictionary(d)
                case .noPermission:
                    var d = [String : JSON]()
                    d[".tag"] = .str("no_permission")
                    return .dictionary(d)
                case .cantShareOutsideTeam:
                    var d = [String : JSON]()
                    d[".tag"] = .str("cant_share_outside_team")
                    return .dictionary(d)
                case .tooManyMembers(let arg):
                    var d = ["too_many_members": Serialization._UInt64Serializer.serialize(arg)]
                    d[".tag"] = .str("too_many_members")
                    return .dictionary(d)
                case .tooManyPendingInvites(let arg):
                    var d = ["too_many_pending_invites": Serialization._UInt64Serializer.serialize(arg)]
                    d[".tag"] = .str("too_many_pending_invites")
                    return .dictionary(d)
                case .rateLimit:
                    var d = [String : JSON]()
                    d[".tag"] = .str("rate_limit")
                    return .dictionary(d)
                case .insufficientPlan:
                    var d = [String : JSON]()
                    d[".tag"] = .str("insufficient_plan")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AddFolderMemberError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return AddFolderMemberError.accessError(v)
                        case "email_unverified":
                            return AddFolderMemberError.emailUnverified
                        case "bad_member":
                            let v = Sharing.AddMemberSelectorErrorSerializer().deserialize(d["bad_member"] ?? .null)
                            return AddFolderMemberError.badMember(v)
                        case "no_permission":
                            return AddFolderMemberError.noPermission
                        case "cant_share_outside_team":
                            return AddFolderMemberError.cantShareOutsideTeam
                        case "too_many_members":
                            let v = Serialization._UInt64Serializer.deserialize(d["too_many_members"] ?? .null)
                            return AddFolderMemberError.tooManyMembers(v)
                        case "too_many_pending_invites":
                            let v = Serialization._UInt64Serializer.deserialize(d["too_many_pending_invites"] ?? .null)
                            return AddFolderMemberError.tooManyPendingInvites(v)
                        case "rate_limit":
                            return AddFolderMemberError.rateLimit
                        case "insufficient_plan":
                            return AddFolderMemberError.insufficientPlan
                        case "other":
                            return AddFolderMemberError.other
                        default:
                            return AddFolderMemberError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The AddMemberSelectorError union
    */
    public enum AddMemberSelectorError: CustomStringConvertible {
        /**
            The value is the ID that could not be identified.
        */
        case invalidDropboxId(String)
        /**
            The value is the e-email address that is malformed.
        */
        case invalidEmail(String)
        /**
            The value is the ID of the Dropbox user with an unverified e-mail address.  Invite unverified users by
            e-mail address instead of by their Dropbox ID.
        */
        case unverifiedDropboxId(String)
        /**
            At least one of the specified groups in members in AddFolderMemberArg is deleted.
        */
        case groupDeleted
        /**
            Sharing to a group that is not on the current account's team.
        */
        case groupNotOnTeam
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(AddMemberSelectorErrorSerializer().serialize(self)))"
        }
    }
    open class AddMemberSelectorErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: AddMemberSelectorError) -> JSON {
            switch value {
                case .invalidDropboxId(let arg):
                    var d = ["invalid_dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("invalid_dropbox_id")
                    return .dictionary(d)
                case .invalidEmail(let arg):
                    var d = ["invalid_email": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("invalid_email")
                    return .dictionary(d)
                case .unverifiedDropboxId(let arg):
                    var d = ["unverified_dropbox_id": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("unverified_dropbox_id")
                    return .dictionary(d)
                case .groupDeleted:
                    var d = [String : JSON]()
                    d[".tag"] = .str("group_deleted")
                    return .dictionary(d)
                case .groupNotOnTeam:
                    var d = [String : JSON]()
                    d[".tag"] = .str("group_not_on_team")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> AddMemberSelectorError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["invalid_dropbox_id"] ?? .null)
                            return AddMemberSelectorError.invalidDropboxId(v)
                        case "invalid_email":
                            let v = Serialization._StringSerializer.deserialize(d["invalid_email"] ?? .null)
                            return AddMemberSelectorError.invalidEmail(v)
                        case "unverified_dropbox_id":
                            let v = Serialization._StringSerializer.deserialize(d["unverified_dropbox_id"] ?? .null)
                            return AddMemberSelectorError.unverifiedDropboxId(v)
                        case "group_deleted":
                            return AddMemberSelectorError.groupDeleted
                        case "group_not_on_team":
                            return AddMemberSelectorError.groupNotOnTeam
                        case "other":
                            return AddMemberSelectorError.other
                        default:
                            return AddMemberSelectorError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The RemoveFolderMemberArg struct
    */
    open class RemoveFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        open let sharedFolderId : String
        /// The member to remove from the folder.
        open let member : Sharing.MemberSelector
        /// If true, the removed user will keep their copy of the folder after it's unshared, assuming it was mounted.
        /// Otherwise, it will be removed from their Dropbox. Also, this must be set to false when kicking a group.
        open let leaveACopy : Bool
        public init(sharedFolderId: String, member: Sharing.MemberSelector, leaveACopy: Bool) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.member = member
            self.leaveACopy = leaveACopy
        }
        open var description : String {
            return "\(prepareJSONForSerialization(RemoveFolderMemberArgSerializer().serialize(self)))"
        }
    }
    open class RemoveFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RemoveFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "leave_a_copy": Serialization._BoolSerializer.serialize(value.leaveACopy),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RemoveFolderMemberArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                    let leaveACopy = Serialization._BoolSerializer.deserialize(dict["leave_a_copy"] ?? .null)
                    return RemoveFolderMemberArg(sharedFolderId: sharedFolderId, member: member, leaveACopy: leaveACopy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The RemoveFolderMemberError union
    */
    public enum RemoveFolderMemberError: CustomStringConvertible {
        case accessError(Sharing.SharedFolderAccessError)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(RemoveFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    open class RemoveFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RemoveFolderMemberError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RemoveFolderMemberError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return RemoveFolderMemberError.accessError(v)
                        case "other":
                            return RemoveFolderMemberError.other
                        default:
                            return RemoveFolderMemberError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UpdateFolderMemberArg struct
    */
    open class UpdateFolderMemberArg: CustomStringConvertible {
        /// The ID for the shared folder.
        open let sharedFolderId : String
        /// The member of the shared folder to update.  Only the dropboxId in MemberSelector may be set at this time.
        open let member : Sharing.MemberSelector
        /// The new access level for member. owner in AccessLevel is disallowed.
        open let accessLevel : Sharing.AccessLevel
        public init(sharedFolderId: String, member: Sharing.MemberSelector, accessLevel: Sharing.AccessLevel) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.member = member
            self.accessLevel = accessLevel
        }
        open var description : String {
            return "\(prepareJSONForSerialization(UpdateFolderMemberArgSerializer().serialize(self)))"
        }
    }
    open class UpdateFolderMemberArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFolderMemberArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            "member": Sharing.MemberSelectorSerializer().serialize(value.member),
            "access_level": Sharing.AccessLevelSerializer().serialize(value.accessLevel),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdateFolderMemberArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    let member = Sharing.MemberSelectorSerializer().deserialize(dict["member"] ?? .null)
                    let accessLevel = Sharing.AccessLevelSerializer().deserialize(dict["access_level"] ?? .null)
                    return UpdateFolderMemberArg(sharedFolderId: sharedFolderId, member: member, accessLevel: accessLevel)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UpdateFolderMemberError union
    */
    public enum UpdateFolderMemberError: CustomStringConvertible {
        case accessError(Sharing.SharedFolderAccessError)
        case memberError(Sharing.SharedFolderMemberError)
        /**
            The current user's account doesn't support this action. An example of this is when downgrading a member from
            editor to viewer. This action can only be performed by users that have upgraded to a Pro or Business plan.
        */
        case insufficientPlan
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(UpdateFolderMemberErrorSerializer().serialize(self)))"
        }
    }
    open class UpdateFolderMemberErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateFolderMemberError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .memberError(let arg):
                    var d = ["member_error": Sharing.SharedFolderMemberErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("member_error")
                    return .dictionary(d)
                case .insufficientPlan:
                    var d = [String : JSON]()
                    d[".tag"] = .str("insufficient_plan")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UpdateFolderMemberError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return UpdateFolderMemberError.accessError(v)
                        case "member_error":
                            let v = Sharing.SharedFolderMemberErrorSerializer().deserialize(d["member_error"] ?? .null)
                            return UpdateFolderMemberError.memberError(v)
                        case "insufficient_plan":
                            return UpdateFolderMemberError.insufficientPlan
                        case "other":
                            return UpdateFolderMemberError.other
                        default:
                            return UpdateFolderMemberError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The MountFolderArg struct
    */
    open class MountFolderArg: CustomStringConvertible {
        /// The ID of the shared folder to mount.
        open let sharedFolderId : String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        open var description : String {
            return "\(prepareJSONForSerialization(MountFolderArgSerializer().serialize(self)))"
        }
    }
    open class MountFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MountFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MountFolderArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    return MountFolderArg(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The MountFolderError union
    */
    public enum MountFolderError: CustomStringConvertible {
        case accessError(Sharing.SharedFolderAccessError)
        /**
            Mounting would cause a shared folder to be inside another, which is disallowed.
        */
        case insideSharedFolder
        /**
            The current user does not have enough space to mount the shared folder.
        */
        case insufficientQuota
        /**
            The shared folder is already mounted.
        */
        case alreadyMounted
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(MountFolderErrorSerializer().serialize(self)))"
        }
    }
    open class MountFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MountFolderError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .insideSharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("inside_shared_folder")
                    return .dictionary(d)
                case .insufficientQuota:
                    var d = [String : JSON]()
                    d[".tag"] = .str("insufficient_quota")
                    return .dictionary(d)
                case .alreadyMounted:
                    var d = [String : JSON]()
                    d[".tag"] = .str("already_mounted")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MountFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return MountFolderError.accessError(v)
                        case "inside_shared_folder":
                            return MountFolderError.insideSharedFolder
                        case "insufficient_quota":
                            return MountFolderError.insufficientQuota
                        case "already_mounted":
                            return MountFolderError.alreadyMounted
                        case "other":
                            return MountFolderError.other
                        default:
                            return MountFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UnmountFolderArg struct
    */
    open class UnmountFolderArg: CustomStringConvertible {
        /// The ID for the shared folder.
        open let sharedFolderId : String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        open var description : String {
            return "\(prepareJSONForSerialization(UnmountFolderArgSerializer().serialize(self)))"
        }
    }
    open class UnmountFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnmountFolderArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UnmountFolderArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    return UnmountFolderArg(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UnmountFolderError union
    */
    public enum UnmountFolderError: CustomStringConvertible {
        case accessError(Sharing.SharedFolderAccessError)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(UnmountFolderErrorSerializer().serialize(self)))"
        }
    }
    open class UnmountFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnmountFolderError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UnmountFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return UnmountFolderError.accessError(v)
                        case "other":
                            return UnmountFolderError.other
                        default:
                            return UnmountFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The RelinquishFolderMembershipArg struct
    */
    open class RelinquishFolderMembershipArg: CustomStringConvertible {
        /// The ID for the shared folder.
        open let sharedFolderId : String
        public init(sharedFolderId: String) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
        }
        open var description : String {
            return "\(prepareJSONForSerialization(RelinquishFolderMembershipArgSerializer().serialize(self)))"
        }
    }
    open class RelinquishFolderMembershipArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelinquishFolderMembershipArg) -> JSON {
            let output = [ 
            "shared_folder_id": Serialization._StringSerializer.serialize(value.sharedFolderId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelinquishFolderMembershipArg {
            switch json {
                case .dictionary(let dict):
                    let sharedFolderId = Serialization._StringSerializer.deserialize(dict["shared_folder_id"] ?? .null)
                    return RelinquishFolderMembershipArg(sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The RelinquishFolderMembershipError union
    */
    public enum RelinquishFolderMembershipError: CustomStringConvertible {
        case accessError(Sharing.SharedFolderAccessError)
        /**
            The current user is the owner of the shared folder. Owners cannot relinquish membership to their own
            folders. Try unsharing or transfering ownership first.
        */
        case folderOwner
        /**
            The shared folder is currently mounted.  Unmount the shared folder before relinquishing membership.
        */
        case mounted
        /**
            The current user has access to the shared folder via a group.  You can't relinquish membership to folders
            shared via groups.
        */
        case groupAccess
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(RelinquishFolderMembershipErrorSerializer().serialize(self)))"
        }
    }
    open class RelinquishFolderMembershipErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelinquishFolderMembershipError) -> JSON {
            switch value {
                case .accessError(let arg):
                    var d = ["access_error": Sharing.SharedFolderAccessErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("access_error")
                    return .dictionary(d)
                case .folderOwner:
                    var d = [String : JSON]()
                    d[".tag"] = .str("folder_owner")
                    return .dictionary(d)
                case .mounted:
                    var d = [String : JSON]()
                    d[".tag"] = .str("mounted")
                    return .dictionary(d)
                case .groupAccess:
                    var d = [String : JSON]()
                    d[".tag"] = .str("group_access")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelinquishFolderMembershipError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "access_error":
                            let v = Sharing.SharedFolderAccessErrorSerializer().deserialize(d["access_error"] ?? .null)
                            return RelinquishFolderMembershipError.accessError(v)
                        case "folder_owner":
                            return RelinquishFolderMembershipError.folderOwner
                        case "mounted":
                            return RelinquishFolderMembershipError.mounted
                        case "group_access":
                            return RelinquishFolderMembershipError.groupAccess
                        case "other":
                            return RelinquishFolderMembershipError.other
                        default:
                            return RelinquishFolderMembershipError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
}
