
/* Autogenerated. Do not edit. */

import Foundation
/**
    Datatypes and serializers for the files namespace
*/
open class Files {
    /**
        Metadata for a file or folder.
    */
    open class Metadata: CustomStringConvertible {
        /// The last component of the path (including extension). This never contains a slash.
        open let name : String
        /// The lowercased full path in the user's Dropbox. This always starts with a slash.
        open let pathLower : String
        /// Set if this file or folder is contained in a shared folder.
        open let parentSharedFolderId : String?
        public init(name: String, pathLower: String, parentSharedFolderId: String? = nil) {
            stringValidator()(value: name)
            self.name = name
            stringValidator()(value: pathLower)
            self.pathLower = pathLower
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(value: parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
        }
        open var description : String {
            return "\(prepareJSONForSerialization(MetadataSerializer().serialize(self)))"
        }
    }
    open class MetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Metadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            ]
            switch value {
                case let file as Files.FileMetadata:
                    for (k,v) in Serialization.getFields(Files.FileMetadataSerializer().serialize(file)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("file")
                case let folder as Files.FolderMetadata:
                    for (k,v) in Serialization.getFields(Files.FolderMetadataSerializer().serialize(folder)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("folder")
                case let deleted as Files.DeletedMetadata:
                    for (k,v) in Serialization.getFields(Files.DeletedMetadataSerializer().serialize(deleted)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("deleted")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> Metadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "file":
                            return Files.FileMetadataSerializer().deserialize(json)
                        case "folder":
                            return Files.FolderMetadataSerializer().deserialize(json)
                        case "deleted":
                            return Files.DeletedMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Dimensions for a photo or video.
    */
    open class Dimensions: CustomStringConvertible {
        /// Height of the photo/video.
        open let height : UInt64
        /// Width of the photo/video.
        open let width : UInt64
        public init(height: UInt64, width: UInt64) {
            comparableValidator()(value: height)
            self.height = height
            comparableValidator()(value: width)
            self.width = width
        }
        open var description : String {
            return "\(prepareJSONForSerialization(DimensionsSerializer().serialize(self)))"
        }
    }
    open class DimensionsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Dimensions) -> JSON {
            let output = [ 
            "height": Serialization._UInt64Serializer.serialize(value.height),
            "width": Serialization._UInt64Serializer.serialize(value.width),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> Dimensions {
            switch json {
                case .dictionary(let dict):
                    let height = Serialization._UInt64Serializer.deserialize(dict["height"] ?? .null)
                    let width = Serialization._UInt64Serializer.deserialize(dict["width"] ?? .null)
                    return Dimensions(height: height, width: width)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        GPS coordinates for a photo or video.
    */
    open class GpsCoordinates: CustomStringConvertible {
        /// Latitude of the GPS coordinates.
        open let latitude : Double
        /// Longitude of the GPS coordinates.
        open let longitude : Double
        public init(latitude: Double, longitude: Double) {
            comparableValidator()(value: latitude)
            self.latitude = latitude
            comparableValidator()(value: longitude)
            self.longitude = longitude
        }
        open var description : String {
            return "\(prepareJSONForSerialization(GpsCoordinatesSerializer().serialize(self)))"
        }
    }
    open class GpsCoordinatesSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GpsCoordinates) -> JSON {
            let output = [ 
            "latitude": Serialization._DoubleSerializer.serialize(value.latitude),
            "longitude": Serialization._DoubleSerializer.serialize(value.longitude),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GpsCoordinates {
            switch json {
                case .dictionary(let dict):
                    let latitude = Serialization._DoubleSerializer.deserialize(dict["latitude"] ?? .null)
                    let longitude = Serialization._DoubleSerializer.deserialize(dict["longitude"] ?? .null)
                    return GpsCoordinates(latitude: latitude, longitude: longitude)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Metadata for a photo or video.
    */
    open class MediaMetadata: CustomStringConvertible {
        /// Dimension of the photo/video.
        open let dimensions : Files.Dimensions?
        /// The GPS coordinate of the photo/video.
        open let location : Files.GpsCoordinates?
        /// The timestamp when the photo/video is taken.
        open let timeTaken : Date?
        public init(dimensions: Files.Dimensions? = nil, location: Files.GpsCoordinates? = nil, timeTaken: Date? = nil) {
            self.dimensions = dimensions
            self.location = location
            self.timeTaken = timeTaken
        }
        open var description : String {
            return "\(prepareJSONForSerialization(MediaMetadataSerializer().serialize(self)))"
        }
    }
    open class MediaMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MediaMetadata) -> JSON {
            var output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            ]
            switch value {
                case let photo as Files.PhotoMetadata:
                    for (k,v) in Serialization.getFields(Files.PhotoMetadataSerializer().serialize(photo)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("photo")
                case let video as Files.VideoMetadata:
                    for (k,v) in Serialization.getFields(Files.VideoMetadataSerializer().serialize(video)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("video")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> MediaMetadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "photo":
                            return Files.PhotoMetadataSerializer().deserialize(json)
                        case "video":
                            return Files.VideoMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Metadata for a photo.
    */
    open class PhotoMetadata: Files.MediaMetadata {
        open override var description : String {
            return "\(prepareJSONForSerialization(PhotoMetadataSerializer().serialize(self)))"
        }
    }
    open class PhotoMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PhotoMetadata) -> JSON {
            let output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PhotoMetadata {
            switch json {
                case .dictionary(let dict):
                    let dimensions = NullableSerializer(Files.DimensionsSerializer()).deserialize(dict["dimensions"] ?? .null)
                    let location = NullableSerializer(Files.GpsCoordinatesSerializer()).deserialize(dict["location"] ?? .null)
                    let timeTaken = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_taken"] ?? .null)
                    return PhotoMetadata(dimensions: dimensions, location: location, timeTaken: timeTaken)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Metadata for a video.
    */
    open class VideoMetadata: Files.MediaMetadata {
        /// The duration of the video in milliseconds.
        open let duration : UInt64?
        public init(dimensions: Files.Dimensions? = nil, location: Files.GpsCoordinates? = nil, timeTaken: Date? = nil, duration: UInt64? = nil) {
            nullableValidator(comparableValidator())(value: duration)
            self.duration = duration
            super.init(dimensions: dimensions, location: location, timeTaken: timeTaken)
        }
        open override var description : String {
            return "\(prepareJSONForSerialization(VideoMetadataSerializer().serialize(self)))"
        }
    }
    open class VideoMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: VideoMetadata) -> JSON {
            let output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            "duration": NullableSerializer(Serialization._UInt64Serializer).serialize(value.duration),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> VideoMetadata {
            switch json {
                case .dictionary(let dict):
                    let dimensions = NullableSerializer(Files.DimensionsSerializer()).deserialize(dict["dimensions"] ?? .null)
                    let location = NullableSerializer(Files.GpsCoordinatesSerializer()).deserialize(dict["location"] ?? .null)
                    let timeTaken = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_taken"] ?? .null)
                    let duration = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["duration"] ?? .null)
                    return VideoMetadata(dimensions: dimensions, location: location, timeTaken: timeTaken, duration: duration)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The MediaInfo union
    */
    public enum MediaInfo: CustomStringConvertible {
        /**
            Indicate the photo/video is still under processing and metadata is not available yet.
        */
        case pending
        /**
            The metadata for the photo/video.
        */
        case metadata(Files.MediaMetadata)
        public var description : String {
            return "\(prepareJSONForSerialization(MediaInfoSerializer().serialize(self)))"
        }
    }
    open class MediaInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: MediaInfo) -> JSON {
            switch value {
                case .pending:
                    var d = [String : JSON]()
                    d[".tag"] = .str("pending")
                    return .dictionary(d)
                case .metadata(let arg):
                    var d = ["metadata": Files.MediaMetadataSerializer().serialize(arg)]
                    d[".tag"] = .str("metadata")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> MediaInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "pending":
                            return MediaInfo.pending
                        case "metadata":
                            let v = Files.MediaMetadataSerializer().deserialize(d["metadata"] ?? .null)
                            return MediaInfo.metadata(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The FileMetadata struct
    */
    open class FileMetadata: Files.Metadata {
        /// A unique identifier for the file.
        open let id : String?
        /// For files, this is the modification time set by the desktop client when the file was added to Dropbox. Since
        /// this time is not verified (the Dropbox server stores whatever the desktop client sends up), this should only
        /// be used for display purposes (such as sorting) and not, for example, to determine if a file has changed or
        /// not.
        open let clientModified : Date
        /// The last time the file was modified on Dropbox.
        open let serverModified : Date
        /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
        /// and can be used to detect changes and avoid conflicts.
        open let rev : String
        /// The file size in bytes.
        open let size : UInt64
        /// Additional information if the file is a photo or video.
        open let mediaInfo : Files.MediaInfo?
        public init(name: String, pathLower: String, clientModified: Date, serverModified: Date, rev: String, size: UInt64, parentSharedFolderId: String? = nil, id: String? = nil, mediaInfo: Files.MediaInfo? = nil) {
            nullableValidator(stringValidator(minLength: 1))(value: id)
            self.id = id
            self.clientModified = clientModified
            self.serverModified = serverModified
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(value: rev)
            self.rev = rev
            comparableValidator()(value: size)
            self.size = size
            self.mediaInfo = mediaInfo
            super.init(name: name, pathLower: pathLower, parentSharedFolderId: parentSharedFolderId)
        }
        open override var description : String {
            return "\(prepareJSONForSerialization(FileMetadataSerializer().serialize(self)))"
        }
    }
    open class FileMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FileMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "client_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.clientModified),
            "server_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.serverModified),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            "size": Serialization._UInt64Serializer.serialize(value.size),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            "media_info": NullableSerializer(Files.MediaInfoSerializer()).serialize(value.mediaInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FileMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .null)
                    let clientModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["client_modified"] ?? .null)
                    let serverModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["server_modified"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    let size = Serialization._UInt64Serializer.deserialize(dict["size"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .null)
                    let mediaInfo = NullableSerializer(Files.MediaInfoSerializer()).deserialize(dict["media_info"] ?? .null)
                    return FileMetadata(name: name, pathLower: pathLower, clientModified: clientModified, serverModified: serverModified, rev: rev, size: size, parentSharedFolderId: parentSharedFolderId, id: id, mediaInfo: mediaInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The FolderMetadata struct
    */
    open class FolderMetadata: Files.Metadata {
        /// A unique identifier for the folder.
        open let id : String?
        /// If this folder is a shared folder mount point, the ID of the shared folder mounted at this location.
        open let sharedFolderId : String?
        public init(name: String, pathLower: String, parentSharedFolderId: String? = nil, id: String? = nil, sharedFolderId: String? = nil) {
            nullableValidator(stringValidator(minLength: 1))(value: id)
            self.id = id
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(value: sharedFolderId)
            self.sharedFolderId = sharedFolderId
            super.init(name: name, pathLower: pathLower, parentSharedFolderId: parentSharedFolderId)
        }
        open override var description : String {
            return "\(prepareJSONForSerialization(FolderMetadataSerializer().serialize(self)))"
        }
    }
    open class FolderMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: FolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            "shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedFolderId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> FolderMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .null)
                    let sharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_folder_id"] ?? .null)
                    return FolderMetadata(name: name, pathLower: pathLower, parentSharedFolderId: parentSharedFolderId, id: id, sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Indicates that there used to be a file or folder at this path, but it no longer exists.
    */
    open class DeletedMetadata: Files.Metadata {
        open override var description : String {
            return "\(prepareJSONForSerialization(DeletedMetadataSerializer().serialize(self)))"
        }
    }
    open class DeletedMetadataSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeletedMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeletedMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    return DeletedMetadata(name: name, pathLower: pathLower, parentSharedFolderId: parentSharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The GetMetadataError union
    */
    public enum GetMetadataError: CustomStringConvertible {
        case path(Files.LookupError)
        public var description : String {
            return "\(prepareJSONForSerialization(GetMetadataErrorSerializer().serialize(self)))"
        }
    }
    open class GetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetMetadataError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return GetMetadataError.path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The GetMetadataArg struct
    */
    open class GetMetadataArg: CustomStringConvertible {
        /// The path of a file or folder on Dropbox
        open let path : String
        /// If true, :field:'FileMetadata.media_info' is set for photo and video.
        open let includeMediaInfo : Bool
        public init(path: String, includeMediaInfo: Bool = false) {
            stringValidator(pattern: "((/|id:).*)|(rev:[0-9a-f]{9,})")(value: path)
            self.path = path
            self.includeMediaInfo = includeMediaInfo
        }
        open var description : String {
            return "\(prepareJSONForSerialization(GetMetadataArgSerializer().serialize(self)))"
        }
    }
    open class GetMetadataArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetMetadataArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .null)
                    return GetMetadataArg(path: path, includeMediaInfo: includeMediaInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderLongpollArg struct
    */
    open class ListFolderLongpollArg: CustomStringConvertible {
        /// A cursor as returned by listFolder or listFolderContinue
        open let cursor : String
        /// A timeout in seconds. The request will block for at most this length of time, plus up to 90 seconds of
        /// random jitter added to avoid the thundering herd problem. Care should be taken when using this parameter, as
        /// some network infrastructure does not support long timeouts.
        open let timeout : UInt64
        public init(cursor: String, timeout: UInt64 = 30) {
            stringValidator()(value: cursor)
            self.cursor = cursor
            comparableValidator(minValue: 30, maxValue: 480)(value: timeout)
            self.timeout = timeout
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListFolderLongpollArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderLongpollArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderLongpollArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "timeout": Serialization._UInt64Serializer.serialize(value.timeout),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderLongpollArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let timeout = Serialization._UInt64Serializer.deserialize(dict["timeout"] ?? .null)
                    return ListFolderLongpollArg(cursor: cursor, timeout: timeout)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderLongpollResult struct
    */
    open class ListFolderLongpollResult: CustomStringConvertible {
        /// Indicates whether new changes are available. If true, call listFolder to retrieve the changes.
        open let changes : Bool
        /// If present, backoff for at least this many seconds before calling listFolderLongpoll again.
        open let backoff : UInt64?
        public init(changes: Bool, backoff: UInt64? = nil) {
            self.changes = changes
            nullableValidator(comparableValidator())(value: backoff)
            self.backoff = backoff
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListFolderLongpollResultSerializer().serialize(self)))"
        }
    }
    open class ListFolderLongpollResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderLongpollResult) -> JSON {
            let output = [ 
            "changes": Serialization._BoolSerializer.serialize(value.changes),
            "backoff": NullableSerializer(Serialization._UInt64Serializer).serialize(value.backoff),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderLongpollResult {
            switch json {
                case .dictionary(let dict):
                    let changes = Serialization._BoolSerializer.deserialize(dict["changes"] ?? .null)
                    let backoff = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["backoff"] ?? .null)
                    return ListFolderLongpollResult(changes: changes, backoff: backoff)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderLongpollError union
    */
    public enum ListFolderLongpollError: CustomStringConvertible {
        /**
            Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
        */
        case reset
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderLongpollErrorSerializer().serialize(self)))"
        }
    }
    open class ListFolderLongpollErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderLongpollError) -> JSON {
            switch value {
                case .reset:
                    var d = [String : JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFolderLongpollError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListFolderLongpollError.reset
                        case "other":
                            return ListFolderLongpollError.other
                        default:
                            return ListFolderLongpollError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ListFolderArg struct
    */
    open class ListFolderArg: CustomStringConvertible {
        /// The path to the folder you want to see the contents of.
        open let path : String
        /// If true, the list folder operation will be applied recursively to all subfolders and the response will
        /// contain contents of all subfolders.
        open let recursive : Bool
        /// If true, :field:'FileMetadata.media_info' is set for photo and video.
        open let includeMediaInfo : Bool
        /// If true, the results will include entries for files and folders that used to exist but were deleted.
        open let includeDeleted : Bool
        public init(path: String, recursive: Bool = false, includeMediaInfo: Bool = false, includeDeleted: Bool = false) {
            stringValidator(pattern: "(/.*)?")(value: path)
            self.path = path
            self.recursive = recursive
            self.includeMediaInfo = includeMediaInfo
            self.includeDeleted = includeDeleted
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListFolderArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "recursive": Serialization._BoolSerializer.serialize(value.recursive),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            "include_deleted": Serialization._BoolSerializer.serialize(value.includeDeleted),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let recursive = Serialization._BoolSerializer.deserialize(dict["recursive"] ?? .null)
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .null)
                    let includeDeleted = Serialization._BoolSerializer.deserialize(dict["include_deleted"] ?? .null)
                    return ListFolderArg(path: path, recursive: recursive, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderResult struct
    */
    open class ListFolderResult: CustomStringConvertible {
        /// The files and (direct) subfolders in the folder.
        open let entries : Array<Files.Metadata>
        /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
        open let cursor : String
        /// If true, then there are more entries available. Pass the cursor to listFolderContinue to retrieve the rest.
        open let hasMore : Bool
        public init(entries: Array<Files.Metadata>, cursor: String, hasMore: Bool) {
            self.entries = entries
            stringValidator()(value: cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListFolderResultSerializer().serialize(self)))"
        }
    }
    open class ListFolderResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.MetadataSerializer()).serialize(value.entries),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.MetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    return ListFolderResult(entries: entries, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderError union
    */
    public enum ListFolderError: CustomStringConvertible {
        case path(Files.LookupError)
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderErrorSerializer().serialize(self)))"
        }
    }
    open class ListFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListFolderError.path(v)
                        case "other":
                            return ListFolderError.other
                        default:
                            return ListFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ListFolderContinueArg struct
    */
    open class ListFolderContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to listFolder or listFolderContinue.
        open let cursor : String
        public init(cursor: String) {
            stringValidator()(value: cursor)
            self.cursor = cursor
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListFolderContinueArgSerializer().serialize(self)))"
        }
    }
    open class ListFolderContinueArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderContinueError union
    */
    public enum ListFolderContinueError: CustomStringConvertible {
        case path(Files.LookupError)
        /**
            Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
        */
        case reset
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderContinueErrorSerializer().serialize(self)))"
        }
    }
    open class ListFolderContinueErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderContinueError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .reset:
                    var d = [String : JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListFolderContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListFolderContinueError.path(v)
                        case "reset":
                            return ListFolderContinueError.reset
                        case "other":
                            return ListFolderContinueError.other
                        default:
                            return ListFolderContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ListFolderGetLatestCursorResult struct
    */
    open class ListFolderGetLatestCursorResult: CustomStringConvertible {
        /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
        open let cursor : String
        public init(cursor: String) {
            stringValidator()(value: cursor)
            self.cursor = cursor
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListFolderGetLatestCursorResultSerializer().serialize(self)))"
        }
    }
    open class ListFolderGetLatestCursorResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListFolderGetLatestCursorResult) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListFolderGetLatestCursorResult {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderGetLatestCursorResult(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The DownloadError union
    */
    public enum DownloadError: CustomStringConvertible {
        case path(Files.LookupError)
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(DownloadErrorSerializer().serialize(self)))"
        }
    }
    open class DownloadErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DownloadError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return DownloadError.path(v)
                        case "other":
                            return DownloadError.other
                        default:
                            return DownloadError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The DownloadArg struct
    */
    open class DownloadArg: CustomStringConvertible {
        /// The path of the file to download.
        open let path : String
        /// Deprecated. Please specify revision in :field:'path' instead
        open let rev : String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "((/|id:).*)|(rev:[0-9a-f]{9,})")(value: path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(value: rev)
            self.rev = rev
        }
        open var description : String {
            return "\(prepareJSONForSerialization(DownloadArgSerializer().serialize(self)))"
        }
    }
    open class DownloadArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DownloadArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DownloadArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .null)
                    return DownloadArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UploadWriteFailed struct
    */
    open class UploadWriteFailed: CustomStringConvertible {
        /// The reason why the file couldn't be saved.
        open let reason : Files.WriteError
        /// The upload session ID; this may be used to retry the commit.
        open let uploadSessionId : String
        public init(reason: Files.WriteError, uploadSessionId: String) {
            self.reason = reason
            stringValidator()(value: uploadSessionId)
            self.uploadSessionId = uploadSessionId
        }
        open var description : String {
            return "\(prepareJSONForSerialization(UploadWriteFailedSerializer().serialize(self)))"
        }
    }
    open class UploadWriteFailedSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadWriteFailed) -> JSON {
            let output = [ 
            "reason": Files.WriteErrorSerializer().serialize(value.reason),
            "upload_session_id": Serialization._StringSerializer.serialize(value.uploadSessionId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadWriteFailed {
            switch json {
                case .dictionary(let dict):
                    let reason = Files.WriteErrorSerializer().deserialize(dict["reason"] ?? .null)
                    let uploadSessionId = Serialization._StringSerializer.deserialize(dict["upload_session_id"] ?? .null)
                    return UploadWriteFailed(reason: reason, uploadSessionId: uploadSessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UploadError union
    */
    public enum UploadError: CustomStringConvertible {
        /**
            Unable to save the uploaded contents to a file.
        */
        case path(Files.UploadWriteFailed)
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadErrorSerializer().serialize(self)))"
        }
    }
    open class UploadErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = Serialization.getFields(Files.UploadWriteFailedSerializer().serialize(arg))
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.UploadWriteFailedSerializer().deserialize(json)
                            return UploadError.path(v)
                        case "other":
                            return UploadError.other
                        default:
                            return UploadError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UploadSessionOffsetError struct
    */
    open class UploadSessionOffsetError: CustomStringConvertible {
        /// The offset up to which data has been collected.
        open let correctOffset : UInt64
        public init(correctOffset: UInt64) {
            comparableValidator()(value: correctOffset)
            self.correctOffset = correctOffset
        }
        open var description : String {
            return "\(prepareJSONForSerialization(UploadSessionOffsetErrorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionOffsetErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionOffsetError) -> JSON {
            let output = [ 
            "correct_offset": Serialization._UInt64Serializer.serialize(value.correctOffset),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionOffsetError {
            switch json {
                case .dictionary(let dict):
                    let correctOffset = Serialization._UInt64Serializer.deserialize(dict["correct_offset"] ?? .null)
                    return UploadSessionOffsetError(correctOffset: correctOffset)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UploadSessionLookupError union
    */
    public enum UploadSessionLookupError: CustomStringConvertible {
        /**
            The upload session id was not found.
        */
        case notFound
        /**
            The specified offset was incorrect. See the value for the correct offset. (This error may occur when a
            previous request was received and processed successfully but the client did not receive the response, e.g.
            due to a network error.)
        */
        case incorrectOffset(Files.UploadSessionOffsetError)
        /**
            You are attempting to append data to an upload session that has alread been closed (i.e. committed).
        */
        case closed
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionLookupErrorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionLookupErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionLookupError) -> JSON {
            switch value {
                case .notFound:
                    var d = [String : JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .incorrectOffset(let arg):
                    var d = Serialization.getFields(Files.UploadSessionOffsetErrorSerializer().serialize(arg))
                    d[".tag"] = .str("incorrect_offset")
                    return .dictionary(d)
                case .closed:
                    var d = [String : JSON]()
                    d[".tag"] = .str("closed")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionLookupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return UploadSessionLookupError.notFound
                        case "incorrect_offset":
                            let v = Files.UploadSessionOffsetErrorSerializer().deserialize(json)
                            return UploadSessionLookupError.incorrectOffset(v)
                        case "closed":
                            return UploadSessionLookupError.closed
                        case "other":
                            return UploadSessionLookupError.other
                        default:
                            return UploadSessionLookupError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UploadSessionFinishError union
    */
    public enum UploadSessionFinishError: CustomStringConvertible {
        /**
            The session arguments are incorrect; the value explains the reason.
        */
        case lookupFailed(Files.UploadSessionLookupError)
        /**
            Unable to save the uploaded contents to a file.
        */
        case path(Files.WriteError)
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionFinishErrorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishError) -> JSON {
            switch value {
                case .lookupFailed(let arg):
                    var d = ["lookup_failed": Files.UploadSessionLookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("lookup_failed")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "lookup_failed":
                            let v = Files.UploadSessionLookupErrorSerializer().deserialize(d["lookup_failed"] ?? .null)
                            return UploadSessionFinishError.lookupFailed(v)
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return UploadSessionFinishError.path(v)
                        case "other":
                            return UploadSessionFinishError.other
                        default:
                            return UploadSessionFinishError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UploadSessionStartResult struct
    */
    open class UploadSessionStartResult: CustomStringConvertible {
        /// A unique identifier for the upload session. Pass this to uploadSessionAppend and uploadSessionFinish.
        open let sessionId : String
        public init(sessionId: String) {
            stringValidator()(value: sessionId)
            self.sessionId = sessionId
        }
        open var description : String {
            return "\(prepareJSONForSerialization(UploadSessionStartResultSerializer().serialize(self)))"
        }
    }
    open class UploadSessionStartResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionStartResult) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionStartResult {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    return UploadSessionStartResult(sessionId: sessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UploadSessionCursor struct
    */
    open class UploadSessionCursor: CustomStringConvertible {
        /// The upload session ID (returned by uploadSessionStart).
        open let sessionId : String
        /// The amount of data that has been uploaded so far. We use this to make sure upload data isn't lost or
        /// duplicated in the event of a network error.
        open let offset : UInt64
        public init(sessionId: String, offset: UInt64) {
            stringValidator()(value: sessionId)
            self.sessionId = sessionId
            comparableValidator()(value: offset)
            self.offset = offset
        }
        open var description : String {
            return "\(prepareJSONForSerialization(UploadSessionCursorSerializer().serialize(self)))"
        }
    }
    open class UploadSessionCursorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionCursor) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "offset": Serialization._UInt64Serializer.serialize(value.offset),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionCursor {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    let offset = Serialization._UInt64Serializer.deserialize(dict["offset"] ?? .null)
                    return UploadSessionCursor(sessionId: sessionId, offset: offset)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Your intent when writing a file to some path. This is used to determine what constitutes a conflict and what the
        autorename strategy is. In some situations, the conflict behavior is identical: (a) If the target path doesn't
        contain anything, the file is always written; no conflict. (b) If the target path contains a folder, it's always
        a conflict. (c) If the target path contains a file with identical contents, nothing gets written; no conflict.
        The conflict checking differs in the case where there's a file at the target path with contents different from
        the contents you're trying to write.
    */
    public enum WriteMode: CustomStringConvertible {
        /**
            Never overwrite the existing file. The autorename strategy is to append a number to the file name. For
            example, "document.txt" might become "document (2).txt".
        */
        case add
        /**
            Always overwrite the existing file. The autorename strategy is the same as it is for add.
        */
        case overwrite
        /**
            Overwrite if the given "rev" matches the existing file's "rev". The autorename strategy is to append the
            string "conflicted copy" to the file name. For example, "document.txt" might become "document (conflicted
            copy).txt" or "document (Panda's conflicted copy).txt".
        */
        case update(String)
        public var description : String {
            return "\(prepareJSONForSerialization(WriteModeSerializer().serialize(self)))"
        }
    }
    open class WriteModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WriteMode) -> JSON {
            switch value {
                case .add:
                    var d = [String : JSON]()
                    d[".tag"] = .str("add")
                    return .dictionary(d)
                case .overwrite:
                    var d = [String : JSON]()
                    d[".tag"] = .str("overwrite")
                    return .dictionary(d)
                case .update(let arg):
                    var d = ["update": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("update")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> WriteMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "add":
                            return WriteMode.add
                        case "overwrite":
                            return WriteMode.overwrite
                        case "update":
                            let v = Serialization._StringSerializer.deserialize(d["update"] ?? .null)
                            return WriteMode.update(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The CommitInfo struct
    */
    open class CommitInfo: CustomStringConvertible {
        /// Path in the user's Dropbox to save the file.
        open let path : String
        /// Selects what to do if the file already exists.
        open let mode : Files.WriteMode
        /// If there's a conflict, as determined by mode, have the Dropbox server try to autorename the file to avoid
        /// conflict.
        open let autorename : Bool
        /// The value to store as the clientModified timestamp. Dropbox automatically records the time at which the file
        /// was written to the Dropbox servers. It can also record an additional timestamp, provided by Dropbox desktop
        /// clients, mobile clients, and API apps of when the file was actually created or modified.
        open let clientModified : Date?
        /// Normally, users are made aware of any file modifications in their Dropbox account via notifications in the
        /// client software. If true, this tells the clients that this modification shouldn't result in a user
        /// notification.
        open let mute : Bool
        public init(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
            self.mode = mode
            self.autorename = autorename
            self.clientModified = clientModified
            self.mute = mute
        }
        open var description : String {
            return "\(prepareJSONForSerialization(CommitInfoSerializer().serialize(self)))"
        }
    }
    open class CommitInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CommitInfo) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": Files.WriteModeSerializer().serialize(value.mode),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "client_modified": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.clientModified),
            "mute": Serialization._BoolSerializer.serialize(value.mute),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CommitInfo {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let mode = Files.WriteModeSerializer().deserialize(dict["mode"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .null)
                    let clientModified = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["client_modified"] ?? .null)
                    let mute = Serialization._BoolSerializer.deserialize(dict["mute"] ?? .null)
                    return CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UploadSessionFinishArg struct
    */
    open class UploadSessionFinishArg: CustomStringConvertible {
        /// Contains the upload session ID and the offset.
        open let cursor : Files.UploadSessionCursor
        /// Contains the path and other optional modifiers for the commit.
        open let commit : Files.CommitInfo
        public init(cursor: Files.UploadSessionCursor, commit: Files.CommitInfo) {
            self.cursor = cursor
            self.commit = commit
        }
        open var description : String {
            return "\(prepareJSONForSerialization(UploadSessionFinishArgSerializer().serialize(self)))"
        }
    }
    open class UploadSessionFinishArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UploadSessionFinishArg) -> JSON {
            let output = [ 
            "cursor": Files.UploadSessionCursorSerializer().serialize(value.cursor),
            "commit": Files.CommitInfoSerializer().serialize(value.commit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UploadSessionFinishArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Files.UploadSessionCursorSerializer().deserialize(dict["cursor"] ?? .null)
                    let commit = Files.CommitInfoSerializer().deserialize(dict["commit"] ?? .null)
                    return UploadSessionFinishArg(cursor: cursor, commit: commit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The SearchMode union
    */
    public enum SearchMode: CustomStringConvertible {
        /**
            Search file and folder names.
        */
        case filename
        /**
            Search file and folder names as well as file contents.
        */
        case filenameAndContent
        /**
            Search for deleted file and folder names.
        */
        case deletedFilename
        public var description : String {
            return "\(prepareJSONForSerialization(SearchModeSerializer().serialize(self)))"
        }
    }
    open class SearchModeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMode) -> JSON {
            switch value {
                case .filename:
                    var d = [String : JSON]()
                    d[".tag"] = .str("filename")
                    return .dictionary(d)
                case .filenameAndContent:
                    var d = [String : JSON]()
                    d[".tag"] = .str("filename_and_content")
                    return .dictionary(d)
                case .deletedFilename:
                    var d = [String : JSON]()
                    d[".tag"] = .str("deleted_filename")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SearchMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMode.filename
                        case "filename_and_content":
                            return SearchMode.filenameAndContent
                        case "deleted_filename":
                            return SearchMode.deletedFilename
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The SearchArg struct
    */
    open class SearchArg: CustomStringConvertible {
        /// The path in the user's Dropbox to search. Should probably be a folder.
        open let path : String
        /// The string to search for. The search string is split on spaces into multiple tokens. For file name
        /// searching, the last token is used for prefix matching (i.e. "bat c" matches "bat cave" but not "batman
        /// car").
        open let query : String
        /// The starting index within the search results (used for paging).
        open let start : UInt64
        /// The maximum number of search results to return.
        open let maxResults : UInt64
        /// The search mode (filename, filename_and_content, or deleted_filename). Note that searching file content is
        /// only available for Dropbox Business accounts.
        open let mode : Files.SearchMode
        public init(path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: Files.SearchMode = .filename) {
            stringValidator(pattern: "(/.*)?")(value: path)
            self.path = path
            stringValidator()(value: query)
            self.query = query
            comparableValidator()(value: start)
            self.start = start
            comparableValidator(minValue: 1, maxValue: 1000)(value: maxResults)
            self.maxResults = maxResults
            self.mode = mode
        }
        open var description : String {
            return "\(prepareJSONForSerialization(SearchArgSerializer().serialize(self)))"
        }
    }
    open class SearchArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "query": Serialization._StringSerializer.serialize(value.query),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            "max_results": Serialization._UInt64Serializer.serialize(value.maxResults),
            "mode": Files.SearchModeSerializer().serialize(value.mode),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let query = Serialization._StringSerializer.deserialize(dict["query"] ?? .null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .null)
                    let maxResults = Serialization._UInt64Serializer.deserialize(dict["max_results"] ?? .null)
                    let mode = Files.SearchModeSerializer().deserialize(dict["mode"] ?? .null)
                    return SearchArg(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Indicates what type of match was found for a given item.
    */
    public enum SearchMatchType: CustomStringConvertible {
        /**
            This item was matched on its file or folder name.
        */
        case filename
        /**
            This item was matched based on its file contents.
        */
        case content
        /**
            This item was matched based on both its contents and its file name.
        */
        case both
        public var description : String {
            return "\(prepareJSONForSerialization(SearchMatchTypeSerializer().serialize(self)))"
        }
    }
    open class SearchMatchTypeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMatchType) -> JSON {
            switch value {
                case .filename:
                    var d = [String : JSON]()
                    d[".tag"] = .str("filename")
                    return .dictionary(d)
                case .content:
                    var d = [String : JSON]()
                    d[".tag"] = .str("content")
                    return .dictionary(d)
                case .both:
                    var d = [String : JSON]()
                    d[".tag"] = .str("both")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SearchMatchType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMatchType.filename
                        case "content":
                            return SearchMatchType.content
                        case "both":
                            return SearchMatchType.both
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The SearchMatch struct
    */
    open class SearchMatch: CustomStringConvertible {
        /// The type of the match.
        open let matchType : Files.SearchMatchType
        /// The metadata for the matched file or folder.
        open let metadata : Files.Metadata
        public init(matchType: Files.SearchMatchType, metadata: Files.Metadata) {
            self.matchType = matchType
            self.metadata = metadata
        }
        open var description : String {
            return "\(prepareJSONForSerialization(SearchMatchSerializer().serialize(self)))"
        }
    }
    open class SearchMatchSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchMatch) -> JSON {
            let output = [ 
            "match_type": Files.SearchMatchTypeSerializer().serialize(value.matchType),
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchMatch {
            switch json {
                case .dictionary(let dict):
                    let matchType = Files.SearchMatchTypeSerializer().deserialize(dict["match_type"] ?? .null)
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return SearchMatch(matchType: matchType, metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The SearchResult struct
    */
    open class SearchResult: CustomStringConvertible {
        /// A list (possibly empty) of matches for the query.
        open let matches : Array<Files.SearchMatch>
        /// Used for paging. If true, indicates there is another page of results available that can be fetched by
        /// calling search again.
        open let more : Bool
        /// Used for paging. Value to set the start argument to when calling search to fetch the next page of results.
        open let start : UInt64
        public init(matches: Array<Files.SearchMatch>, more: Bool, start: UInt64) {
            self.matches = matches
            self.more = more
            comparableValidator()(value: start)
            self.start = start
        }
        open var description : String {
            return "\(prepareJSONForSerialization(SearchResultSerializer().serialize(self)))"
        }
    }
    open class SearchResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchResult) -> JSON {
            let output = [ 
            "matches": ArraySerializer(Files.SearchMatchSerializer()).serialize(value.matches),
            "more": Serialization._BoolSerializer.serialize(value.more),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> SearchResult {
            switch json {
                case .dictionary(let dict):
                    let matches = ArraySerializer(Files.SearchMatchSerializer()).deserialize(dict["matches"] ?? .null)
                    let more = Serialization._BoolSerializer.deserialize(dict["more"] ?? .null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .null)
                    return SearchResult(matches: matches, more: more, start: start)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The SearchError union
    */
    public enum SearchError: CustomStringConvertible {
        case path(Files.LookupError)
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(SearchErrorSerializer().serialize(self)))"
        }
    }
    open class SearchErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: SearchError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> SearchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return SearchError.path(v)
                        case "other":
                            return SearchError.other
                        default:
                            return SearchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The LookupError union
    */
    public enum LookupError: CustomStringConvertible {
        case malformedPath(String?)
        /**
            There is nothing at the given path.
        */
        case notFound
        /**
            We were expecting a file, but the given path refers to something that isn't a file.
        */
        case notFile
        /**
            We were expecting a folder, but the given path refers to something that isn't a folder.
        */
        case notFolder
        /**
            The file cannot be transferred because the content is restricted.  For example, sometimes there are legal
            restrictions due to copyright claims.
        */
        case restrictedContent
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(LookupErrorSerializer().serialize(self)))"
        }
    }
    open class LookupErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LookupError) -> JSON {
            switch value {
                case .malformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("malformed_path")
                    return .dictionary(d)
                case .notFound:
                    var d = [String : JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notFile:
                    var d = [String : JSON]()
                    d[".tag"] = .str("not_file")
                    return .dictionary(d)
                case .notFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("not_folder")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String : JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LookupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["malformed_path"] ?? .null)
                            return LookupError.malformedPath(v)
                        case "not_found":
                            return LookupError.notFound
                        case "not_file":
                            return LookupError.notFile
                        case "not_folder":
                            return LookupError.notFolder
                        case "restricted_content":
                            return LookupError.restrictedContent
                        case "other":
                            return LookupError.other
                        default:
                            return LookupError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The WriteError union
    */
    public enum WriteError: CustomStringConvertible {
        case malformedPath(String?)
        /**
            Couldn't write to the target path because there was something in the way.
        */
        case conflict(Files.WriteConflictError)
        /**
            The user doesn't have permissions to write to the target location.
        */
        case noWritePermission
        /**
            The user doesn't have enough available space (bytes) to write more data.
        */
        case insufficientSpace
        /**
            Dropbox will not save the file or folder because it of its name.
        */
        case disallowedName
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(WriteErrorSerializer().serialize(self)))"
        }
    }
    open class WriteErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WriteError) -> JSON {
            switch value {
                case .malformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("malformed_path")
                    return .dictionary(d)
                case .conflict(let arg):
                    var d = ["conflict": Files.WriteConflictErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("conflict")
                    return .dictionary(d)
                case .noWritePermission:
                    var d = [String : JSON]()
                    d[".tag"] = .str("no_write_permission")
                    return .dictionary(d)
                case .insufficientSpace:
                    var d = [String : JSON]()
                    d[".tag"] = .str("insufficient_space")
                    return .dictionary(d)
                case .disallowedName:
                    var d = [String : JSON]()
                    d[".tag"] = .str("disallowed_name")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> WriteError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["malformed_path"] ?? .null)
                            return WriteError.malformedPath(v)
                        case "conflict":
                            let v = Files.WriteConflictErrorSerializer().deserialize(d["conflict"] ?? .null)
                            return WriteError.conflict(v)
                        case "no_write_permission":
                            return WriteError.noWritePermission
                        case "insufficient_space":
                            return WriteError.insufficientSpace
                        case "disallowed_name":
                            return WriteError.disallowedName
                        case "other":
                            return WriteError.other
                        default:
                            return WriteError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The WriteConflictError union
    */
    public enum WriteConflictError: CustomStringConvertible {
        /**
            There's a file in the way.
        */
        case file
        /**
            There's a folder in the way.
        */
        case folder
        /**
            There's a file at an ancestor path, so we couldn't create the required parent folders.
        */
        case fileAncestor
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(WriteConflictErrorSerializer().serialize(self)))"
        }
    }
    open class WriteConflictErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: WriteConflictError) -> JSON {
            switch value {
                case .file:
                    var d = [String : JSON]()
                    d[".tag"] = .str("file")
                    return .dictionary(d)
                case .folder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("folder")
                    return .dictionary(d)
                case .fileAncestor:
                    var d = [String : JSON]()
                    d[".tag"] = .str("file_ancestor")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> WriteConflictError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return WriteConflictError.file
                        case "folder":
                            return WriteConflictError.folder
                        case "file_ancestor":
                            return WriteConflictError.fileAncestor
                        case "other":
                            return WriteConflictError.other
                        default:
                            return WriteConflictError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The CreateFolderArg struct
    */
    open class CreateFolderArg: CustomStringConvertible {
        /// Path in the user's Dropbox to create.
        open let path : String
        public init(path: String) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
        }
        open var description : String {
            return "\(prepareJSONForSerialization(CreateFolderArgSerializer().serialize(self)))"
        }
    }
    open class CreateFolderArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> CreateFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return CreateFolderArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The CreateFolderError union
    */
    public enum CreateFolderError: CustomStringConvertible {
        case path(Files.WriteError)
        public var description : String {
            return "\(prepareJSONForSerialization(CreateFolderErrorSerializer().serialize(self)))"
        }
    }
    open class CreateFolderErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CreateFolderError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CreateFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return CreateFolderError.path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The DeleteArg struct
    */
    open class DeleteArg: CustomStringConvertible {
        /// Path in the user's Dropbox to delete.
        open let path : String
        public init(path: String) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
        }
        open var description : String {
            return "\(prepareJSONForSerialization(DeleteArgSerializer().serialize(self)))"
        }
    }
    open class DeleteArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> DeleteArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return DeleteArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The DeleteError union
    */
    public enum DeleteError: CustomStringConvertible {
        case pathLookup(Files.LookupError)
        case pathWrite(Files.WriteError)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(DeleteErrorSerializer().serialize(self)))"
        }
    }
    open class DeleteErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: DeleteError) -> JSON {
            switch value {
                case .pathLookup(let arg):
                    var d = ["path_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_lookup")
                    return .dictionary(d)
                case .pathWrite(let arg):
                    var d = ["path_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_write")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> DeleteError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["path_lookup"] ?? .null)
                            return DeleteError.pathLookup(v)
                        case "path_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["path_write"] ?? .null)
                            return DeleteError.pathWrite(v)
                        case "other":
                            return DeleteError.other
                        default:
                            return DeleteError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The RelocationArg struct
    */
    open class RelocationArg: CustomStringConvertible {
        /// Path in the user's Dropbox to be copied or moved.
        open let fromPath : String
        /// Path in the user's Dropbox that is the destination.
        open let toPath : String
        public init(fromPath: String, toPath: String) {
            stringValidator(pattern: "/.*")(value: fromPath)
            self.fromPath = fromPath
            stringValidator(pattern: "/.*")(value: toPath)
            self.toPath = toPath
        }
        open var description : String {
            return "\(prepareJSONForSerialization(RelocationArgSerializer().serialize(self)))"
        }
    }
    open class RelocationArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationArg) -> JSON {
            let output = [ 
            "from_path": Serialization._StringSerializer.serialize(value.fromPath),
            "to_path": Serialization._StringSerializer.serialize(value.toPath),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RelocationArg {
            switch json {
                case .dictionary(let dict):
                    let fromPath = Serialization._StringSerializer.deserialize(dict["from_path"] ?? .null)
                    let toPath = Serialization._StringSerializer.deserialize(dict["to_path"] ?? .null)
                    return RelocationArg(fromPath: fromPath, toPath: toPath)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The RelocationError union
    */
    public enum RelocationError: CustomStringConvertible {
        case fromLookup(Files.LookupError)
        case fromWrite(Files.WriteError)
        case to(Files.WriteError)
        /**
            Shared folders can't be copied.
        */
        case cantCopySharedFolder
        /**
            Your move operation would result in nested shared folders.  This is not allowed.
        */
        case cantNestSharedFolder
        /**
            The operation would involve more than 10,000 files and folders.
        */
        case tooManyFiles
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(RelocationErrorSerializer().serialize(self)))"
        }
    }
    open class RelocationErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RelocationError) -> JSON {
            switch value {
                case .fromLookup(let arg):
                    var d = ["from_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_lookup")
                    return .dictionary(d)
                case .fromWrite(let arg):
                    var d = ["from_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_write")
                    return .dictionary(d)
                case .to(let arg):
                    var d = ["to": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("to")
                    return .dictionary(d)
                case .cantCopySharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("cant_copy_shared_folder")
                    return .dictionary(d)
                case .cantNestSharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("cant_nest_shared_folder")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String : JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RelocationError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "from_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["from_lookup"] ?? .null)
                            return RelocationError.fromLookup(v)
                        case "from_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["from_write"] ?? .null)
                            return RelocationError.fromWrite(v)
                        case "to":
                            let v = Files.WriteErrorSerializer().deserialize(d["to"] ?? .null)
                            return RelocationError.to(v)
                        case "cant_copy_shared_folder":
                            return RelocationError.cantCopySharedFolder
                        case "cant_nest_shared_folder":
                            return RelocationError.cantNestSharedFolder
                        case "too_many_files":
                            return RelocationError.tooManyFiles
                        case "other":
                            return RelocationError.other
                        default:
                            return RelocationError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ThumbnailSize union
    */
    public enum ThumbnailSize: CustomStringConvertible {
        /**
            32 by 32 px.
        */
        case w32h32
        /**
            64 by 64 px.
        */
        case w64h64
        /**
            128 by 128 px.
        */
        case w128h128
        /**
            640 by 480 px.
        */
        case w640h480
        /**
            1024 by 768
        */
        case w1024h768
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailSizeSerializer().serialize(self)))"
        }
    }
    open class ThumbnailSizeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailSize) -> JSON {
            switch value {
                case .w32h32:
                    var d = [String : JSON]()
                    d[".tag"] = .str("w32h32")
                    return .dictionary(d)
                case .w64h64:
                    var d = [String : JSON]()
                    d[".tag"] = .str("w64h64")
                    return .dictionary(d)
                case .w128h128:
                    var d = [String : JSON]()
                    d[".tag"] = .str("w128h128")
                    return .dictionary(d)
                case .w640h480:
                    var d = [String : JSON]()
                    d[".tag"] = .str("w640h480")
                    return .dictionary(d)
                case .w1024h768:
                    var d = [String : JSON]()
                    d[".tag"] = .str("w1024h768")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailSize {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "w32h32":
                            return ThumbnailSize.w32h32
                        case "w64h64":
                            return ThumbnailSize.w64h64
                        case "w128h128":
                            return ThumbnailSize.w128h128
                        case "w640h480":
                            return ThumbnailSize.w640h480
                        case "w1024h768":
                            return ThumbnailSize.w1024h768
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ThumbnailFormat union
    */
    public enum ThumbnailFormat: CustomStringConvertible {
        case jpeg
        case png
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailFormatSerializer().serialize(self)))"
        }
    }
    open class ThumbnailFormatSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailFormat) -> JSON {
            switch value {
                case .jpeg:
                    var d = [String : JSON]()
                    d[".tag"] = .str("jpeg")
                    return .dictionary(d)
                case .png:
                    var d = [String : JSON]()
                    d[".tag"] = .str("png")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailFormat {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "jpeg":
                            return ThumbnailFormat.jpeg
                        case "png":
                            return ThumbnailFormat.png
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ThumbnailArg struct
    */
    open class ThumbnailArg: CustomStringConvertible {
        /// The path to the image file you want to thumbnail.
        open let path : String
        /// The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg should be
        /// preferred, while png is  better for screenshots and digital arts.
        open let format : Files.ThumbnailFormat
        /// The size for the thumbnail image.
        open let size : Files.ThumbnailSize
        public init(path: String, format: Files.ThumbnailFormat = .jpeg, size: Files.ThumbnailSize = .w64h64) {
            stringValidator(pattern: "((/|id:).*)|(rev:[0-9a-f]{9,})")(value: path)
            self.path = path
            self.format = format
            self.size = size
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ThumbnailArgSerializer().serialize(self)))"
        }
    }
    open class ThumbnailArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "format": Files.ThumbnailFormatSerializer().serialize(value.format),
            "size": Files.ThumbnailSizeSerializer().serialize(value.size),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ThumbnailArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let format = Files.ThumbnailFormatSerializer().deserialize(dict["format"] ?? .null)
                    let size = Files.ThumbnailSizeSerializer().deserialize(dict["size"] ?? .null)
                    return ThumbnailArg(path: path, format: format, size: size)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ThumbnailError union
    */
    public enum ThumbnailError: CustomStringConvertible {
        /**
            An error occurs when downloading metadata for the image.
        */
        case path(Files.LookupError)
        /**
            The file extension doesn't allow conversion to a thumbnail.
        */
        case unsupportedExtension
        /**
            The image cannot be converted to a thumbnail.
        */
        case unsupportedImage
        /**
            An error occurs during thumbnail conversion.
        */
        case conversionError
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailErrorSerializer().serialize(self)))"
        }
    }
    open class ThumbnailErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ThumbnailError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedExtension:
                    var d = [String : JSON]()
                    d[".tag"] = .str("unsupported_extension")
                    return .dictionary(d)
                case .unsupportedImage:
                    var d = [String : JSON]()
                    d[".tag"] = .str("unsupported_image")
                    return .dictionary(d)
                case .conversionError:
                    var d = [String : JSON]()
                    d[".tag"] = .str("conversion_error")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ThumbnailError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ThumbnailError.path(v)
                        case "unsupported_extension":
                            return ThumbnailError.unsupportedExtension
                        case "unsupported_image":
                            return ThumbnailError.unsupportedImage
                        case "conversion_error":
                            return ThumbnailError.conversionError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The PreviewArg struct
    */
    open class PreviewArg: CustomStringConvertible {
        /// The path of the file to preview.
        open let path : String
        /// Deprecated. Please specify revision in :field:'path' instead
        open let rev : String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "((/|id:).*)|(rev:[0-9a-f]{9,})")(value: path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(value: rev)
            self.rev = rev
        }
        open var description : String {
            return "\(prepareJSONForSerialization(PreviewArgSerializer().serialize(self)))"
        }
    }
    open class PreviewArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PreviewArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> PreviewArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .null)
                    return PreviewArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The PreviewError union
    */
    public enum PreviewError: CustomStringConvertible {
        /**
            An error occurs when downloading metadata for the file.
        */
        case path(Files.LookupError)
        /**
            This preview generation is still in progress and the file is not ready  for preview yet.
        */
        case inProgress
        /**
            The file extension is not supported preview generation.
        */
        case unsupportedExtension
        /**
            The file content is not supported for preview generation.
        */
        case unsupportedContent
        public var description : String {
            return "\(prepareJSONForSerialization(PreviewErrorSerializer().serialize(self)))"
        }
    }
    open class PreviewErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: PreviewError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .inProgress:
                    var d = [String : JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .unsupportedExtension:
                    var d = [String : JSON]()
                    d[".tag"] = .str("unsupported_extension")
                    return .dictionary(d)
                case .unsupportedContent:
                    var d = [String : JSON]()
                    d[".tag"] = .str("unsupported_content")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> PreviewError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return PreviewError.path(v)
                        case "in_progress":
                            return PreviewError.inProgress
                        case "unsupported_extension":
                            return PreviewError.unsupportedExtension
                        case "unsupported_content":
                            return PreviewError.unsupportedContent
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ListRevisionsArg struct
    */
    open class ListRevisionsArg: CustomStringConvertible {
        /// The path to the file you want to see the revisions of.
        open let path : String
        /// The maximum number of revision entries returned.
        open let limit : UInt64
        public init(path: String, limit: UInt64 = 10) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
            comparableValidator(minValue: 1, maxValue: 100)(value: limit)
            self.limit = limit
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsArgSerializer().serialize(self)))"
        }
    }
    open class ListRevisionsArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListRevisionsArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "limit": Serialization._UInt64Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListRevisionsArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let limit = Serialization._UInt64Serializer.deserialize(dict["limit"] ?? .null)
                    return ListRevisionsArg(path: path, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListRevisionsError union
    */
    public enum ListRevisionsError: CustomStringConvertible {
        case path(Files.LookupError)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsErrorSerializer().serialize(self)))"
        }
    }
    open class ListRevisionsErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListRevisionsError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ListRevisionsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListRevisionsError.path(v)
                        case "other":
                            return ListRevisionsError.other
                        default:
                            return ListRevisionsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ListRevisionsResult struct
    */
    open class ListRevisionsResult: CustomStringConvertible {
        /// If the file is deleted.
        open let isDeleted : Bool
        /// The revisions for the file. Only non-delete revisions will show up here.
        open let entries : Array<Files.FileMetadata>
        public init(isDeleted: Bool, entries: Array<Files.FileMetadata>) {
            self.isDeleted = isDeleted
            self.entries = entries
        }
        open var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsResultSerializer().serialize(self)))"
        }
    }
    open class ListRevisionsResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ListRevisionsResult) -> JSON {
            let output = [ 
            "is_deleted": Serialization._BoolSerializer.serialize(value.isDeleted),
            "entries": ArraySerializer(Files.FileMetadataSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> ListRevisionsResult {
            switch json {
                case .dictionary(let dict):
                    let isDeleted = Serialization._BoolSerializer.deserialize(dict["is_deleted"] ?? .null)
                    let entries = ArraySerializer(Files.FileMetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    return ListRevisionsResult(isDeleted: isDeleted, entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The RestoreArg struct
    */
    open class RestoreArg: CustomStringConvertible {
        /// The path to the file you want to restore.
        open let path : String
        /// The revision to restore for the file.
        open let rev : String
        public init(path: String, rev: String) {
            stringValidator(pattern: "/.*")(value: path)
            self.path = path
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(value: rev)
            self.rev = rev
        }
        open var description : String {
            return "\(prepareJSONForSerialization(RestoreArgSerializer().serialize(self)))"
        }
    }
    open class RestoreArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RestoreArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RestoreArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    return RestoreArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The RestoreError union
    */
    public enum RestoreError: CustomStringConvertible {
        /**
            An error occurs when downloading metadata for the file.
        */
        case pathLookup(Files.LookupError)
        /**
            An error occurs when trying to restore the file to that path.
        */
        case pathWrite(Files.WriteError)
        /**
            The revision is invalid. It may point to a different file.
        */
        case invalidRevision
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(RestoreErrorSerializer().serialize(self)))"
        }
    }
    open class RestoreErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RestoreError) -> JSON {
            switch value {
                case .pathLookup(let arg):
                    var d = ["path_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_lookup")
                    return .dictionary(d)
                case .pathWrite(let arg):
                    var d = ["path_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_write")
                    return .dictionary(d)
                case .invalidRevision:
                    var d = [String : JSON]()
                    d[".tag"] = .str("invalid_revision")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RestoreError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["path_lookup"] ?? .null)
                            return RestoreError.pathLookup(v)
                        case "path_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["path_write"] ?? .null)
                            return RestoreError.pathWrite(v)
                        case "invalid_revision":
                            return RestoreError.invalidRevision
                        case "other":
                            return RestoreError.other
                        default:
                            return RestoreError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
}
